
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate, lineno]{lipics-v2021}
\usepackage[mode=buildnew]{standalone}% requires -shell-escape

\usepackage{minted}
\usepackage{macro}
\usepackage{custom_ref}
\usepackage{tree}
\usepackage{mathtools}

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\usetikzlibrary{positioning}

\bibliographystyle{plainurl}% the mandatory bibstyle
\title{Operational semantics for Prolog with Cut in \rocqP and its application to determinacy analysis} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Jane {Open Access}}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}

\authorrunning{J. Open Access and J.\,R. Public} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Dummy keyword} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
\end{abstract}

\section{Introduction}


\elpiP is a dialect of \lprologP (see \cite{1991miller-pf,Miller_Nadathur_2012,dunchev15lpar,TASSI_2019})
used as an extension language for the \rocqP prover (formerly the \coqP proof
assistant). \elpiP has become an important infrastructure component: several
projects and libraries depend on it~\cite{krebbers25,Trakt,Trocq,Maas2024,fissore2023,fissore2024}.
Examples include the Hierarchy-Builder library-structuring tool~\cite{cohen_et_al:LIPIcs.FSCD.2020.34}
and Derive~\cite{tassi2018,tassi2019,tassi2023}, a program-and-proof synthesis
framework with industrial applications at SkyLabs AI.

Starting with version 3, \elpiP gained a static analysis for
determinacy~\cite{10.1007/978-3-032-15981-6_5} to help users tame
backtracking. \rocqP users are familiar with functional programming but
not necessarily with logic programming and uncontrolled backtracking
is a common source of inefficiency and makes debugging harder. The
determinacy checkers identifies predicates that behave like functions,
i.e., predicates that commit to their first solution and leave no
\emph{choice points} (places where backtracking could resume).

This paper reports our first steps towards a mechanization, in the \rocqP
prover, of the determinacy analysis from~\cite{10.1007/978-3-032-15981-6_5}.
We focus on the control operator \emph{cut}, which is useful to restrict
backtracking but makes the semantic depart from a pure logical reading.

We formalize two operational semantics for \prologP with cut. The first is a
stack-based semantics that closely models \elpiP's implementation and is
similar to the semantics mechanized by Pusch in \isabelleP~\cite{10.1007/BFb0105415}
and to the model of Debray and Mishra~\cite[Sec.~4.3]{10.1016/0743-1066(88)90007-6}.
This stack-based semantics is a good starting point to study further
optimizations used by standard \prologP abstract machines~\cite{warren1983abstract,10.7551/mitpress/7160.001.0001},
but it makes reasoning about the scope of \emph{cut} difficult. To address
that limitation we introduce a tree-based semantics in which the branches
pruned by \emph{cut} are explicit and we prove the two semantics equivalent.
Using the tree-based semantics we then show that if every rule of a
predicate passes the determinacy analysis, the call to a deterministic
predicate does not leave any choice points.

\section{Common code: the language}

\begin{figure}
  \input{tex_code/base_type.tex}

  \begin{minipage}{0.49\textwidth}
  \input{tex_code/tm_type.tex}
  \end{minipage}
  \begin{minipage}{0.49\textwidth}
  \input{tex_code/call_type.tex}
  \end{minipage}
  \caption{Tm and Callable types}
  \label{fig:tm-call}
\end{figure}

Before going to the two semantcis, we show the piece of data structure that \marginpar{put unif and program in variable: hides from types}
are shared by the them. The smallest unit of code that we can use in the
langauge is an atom. The atom inductive (see~\cref{type:atom}) is
either a cut or a call. A call
carries a callable term~(see \cref{fig:tm-call}). A term (Tm) is either a predicate,
a datum, a variable or the binary application of a term to another. A Callable is 
a term accepting predicates only predicates as functors.

\mvspace{}
\deftypes[type:atom]{tex_code/atom_type.tex}
\deftypes[type:r]{tex_code/R_type.tex}
\deftypes[type:prog]{tex_code/program_type.tex}
\deftypes[type:sigma]{tex_code/sigma_type.tex}
\deftypes[type:bc]{tex_code/bc_type.tex}
\mvspace{}

A rule (see~\cref{type:r}) is made a head of type term and a list of premises,\marginpar{!!!: controllare il tipo di bc nel testo}
the premises are atoms. A program (see~\cref{type:prog}) is made by a list of
rules and a mapping from predicates to their signatures. The type sigT is the
classic type from the simply typed lambda calculus, i.e. it is either a base
type or an arrow. We decorate arrows to know the mode of the lhs type.

A substitution (see \cref{type:sigma}) is a mapping from variables to terms.
It is the output of a successful query and is often called the output of
a query.

\input{tex_code/unif_type.tex}

The backchain function (bc, see~\cref{type:bc}) filters the rules in the program
that can be used on a given query. It takes: a unifcator $U$ which explains how
to unify terms up to standard unifcation (for output terms) or matching (for
input terms); a program $P$ to explore and filter; a set $S$ of free variable
(fvS) allowing to fresh the program $P$ by renaming the its variables; a query
$q$; and the substitution $\sigma$ in which the query $q$ lives. The result of a
backchain operation is couple made of an extension of $S$ containing the new
variables that have been allocated during the unification phase and a list of
filtered rules $r$ accompagnate by their a subistution. This substitution is the
result of the unification of $q$ with the head of each rule in $r$.

In \cref{fig:prog}, we have an example of a simple \elpiP program which will be used in the
following section of the paper as an example to show how backtracking and
the cut operator works in the semantcis we propose. The translation
of these rules in the \rocqP representation is straightforword.

\begin{figure}[!h]
\inputminted[fontsize=\small,autogobble,escapeinside=~~,mathescape=true,frame=leftline,framerule=0pt,framesep=1em]{elpi}{./prog.elpi}
\caption{Small \elpiP program example}
\label{fig:prog}
\end{figure}

\subsection{The cut operator}
\marginpar{se metti r1 = g A B :- f A B. allora g e f sono funzioni, e puoi
spiegare anche l'idea del detcheck qui}

The semantics of the cut operator adopted in the \textsc{\elpiP} language
corresponds to the \emph{hard cut} operator of standard \textsc{SWI-Prolog}.
This operator has two primary purposes. First, it eliminates all
alternatives that are created either simultaneously with, or after, the
introduction of the cut into the execution state.

To illustrate this high-level description, consider the program shown in
\cref{fig:prog} and the query $q = \elpiIn{g 2 Z}$. All three rules for
\eI{g} can be used on the query $q$. They are tried according to their
order of appearance in the program: rule $r_1$ is tried first, followed by
$r_2$, and $r_3$.

The first rule has no premises and immediately returns the assignment
\eI{Z = 2}. However, the computation does not terminate at this point, since
two additional unexplored alternatives remain, corresponding to the premises
of rules $r_2$ and $r_3$.

The premises of rule $r_2$ are \eI{r 2 Z, !}. At this stage, the role of the
cut becomes apparent. If the premise \eI{r 2 Z} succeeds, the cut commits to
this choice and removes the premises of rule $r_3$ from the alternative list,
as they were generated at the same point as the cut. Moreover, if
the call \eI{r 2 Z} itself produces multiple alternatives, only the first one
is committed, while the remaining alternatives are discarded. This is because
such alternatives have been created at a deeper depth in the search tree than the cut.

Concretely, the call \eI{r 2 Z} yields two solutions, assigning \eI{Z} the
values \eI{4} and \eI{8}, respectively. The second solution is eliminated by
the cut, and only the first assignment is preserved.



\section{Semantics intro}

We propose two operational semantics for a logic program with cut. The two
semantics are based on different syntaxes, the first syntax (called tree)
exploits a tree-like structure and is ideal both to have a graphical view of its
evolution while the state is being intepreted and to prove lemmas over it. The
second syntax, called elpi, is the \elpiP's syntax and has the advantage of
reducing the computational cost of cutting and backtracking alternatives by
using shared pointers. We aim to prove the equivalence of the two semantics
together with some interesting lemmas of the cut behavior.


\section{Tree semantics}
\input{tex_code/tree_def.tex}

In the tree we distinguish 5 main cases: \koC, \okC, and are special
meta-symbols representing, respectively, the failed and a successful
terminal. These symbols are considered meta because they are internal
intermediate symbols used to give structure to the tree.

The \taC constructor (acronym for tree-atom) is the constructor of atoms in the
tree. \marginpar{TA = Todo/Goal?}

The two recursive cases of a tree are the \orC and \andC non-terminals. 
\marginpar{non-terminal Ã¨ roba di grammatiche, usa nodes/constructors}
The \orC
non-terminal \(A \lor B_\sigma\) denotes a disjunction between two trees \(A\) and
\(B\). The first branch is optional, if absent it represents a dead tree,
i.e. a tree that has been entirely explored.
The second branch is annotated with a suspended substitution \(\sigma\) so
that, upon backtracking to \(B\), \(\sigma\) is used as the initial substitution
for the execution of \(B\).

The \andC non-terminal \(A \land_{B_0} B\) represents a conjunction of two trees \(A\)
and \(B\). We call \(B_0\) the reset point for \(B\); it is used to restore the state
of \(B\) to its initial form if a backtracking operation occurs on \(A\). Intuitively,
let \ttl be the function flattening a tree in a list of sequents disjnction, 
in \prologP-like syntax the tree \(A \land_{B_0} B\)
becomes $(A_1, \ttl\ B); (A_2, B_0); \dots; (A_n, B_0)$ where  $\ttl (A) = A_1,\dots, A_n$.
\marginpar{t2l nope, metti un r3 = g X Z :- r .., f .., !, 
e rifatti all'esempio della sezione prima (fai in modo che f funzioni solo con
la seconda regola per r)}

A graphical representation of a tree is shown in \cref{tree-ex1}. To make the
graph more compact, the \andC and \orC non-terminals are n-ary rather than binary,
with right-binding priority. \marginpar{associate to the...} The \koC terminal act as the neutral elements 
in the \orC list, while \okC is the neutral element of the \andC list.


% \begin{figure}
%   \input{tex_code/step_tag.tex}
%   \input{tex_code/step.tex}
% \caption{Step for tree semantics}
% \end{figure}

% \begin{figure}
%   \input{tex_code/next_alt.tex}
% \caption{backtracking operation}
% \end{figure}

The interpretation of a tree is performed by two main routines: \step and \na
that traverse the tree depth-first, left-to-right. Then, then \run inductive
makes the transitive closure of step \step and \na: it iterates the calls to its
auxiliary functions.\marginpar{as much as needed, indee prolog programs do not necessarily terminate} In \cref{type:stepT,type:naT,type:runT} we give the types
contrats of these symbols where \cI{fvS} is a set of variable names.

\mvspace{}
\deftypes[type:steptag]{tex_code/step_tag.tex}
\deftypes[type:stepT]{tex_code/step_sig.tex}
\deftypes[type:naT]{tex_code/next_alt.tex}
\deftypes[type:runT]{tex_code/run_sig.tex}

\mvspace{}
% A particular tree we want to identify is a \isdead tree (defined in \cref{fig:dead}). This tree has the
% property to never produce a solution: it is eiher the \deadC tree
% or both branches of \orC are dead, or the lhs of \andC is dead. In the 
% latter case, we note that $B$ can be non-dead, but this is not a problem
% since the interpreter can run $B$ only if $A$ is non-dead.

\begin{figure}
  \begin{subfigure}{0.45\textwidth}
  \input{tex_code/get_end.tex}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
\input{tex_code/get_subst.tex}
\input{tex_code/path_end.tex}
\input{tex_code/succ_path.tex}
\input{tex_code/failed_path.tex}
\input{tex_code/path_atom.tex}

  \end{subfigure}

  \caption{Defintion of \getend}
  \label{fig:getend}
\end{figure}

The tree interpreter, as in prolog, explores the state in DFS strategy,
to discover the substitution and the leaf of the tree that should
be interpreted.
The \getend routine, shown in~\cref{fig:getend}, accomplishes to this task.
The \getend returns its inputs if the tree is a leaf.
Otherwise, if the tree is a disjunction, the path continues on
the left subtree, if it exists, otherwise it recursively 
retrieves the wanted piece of information in the rhs 
using the substitution stored in the \orC branch: the current
substition when we cross the rhs of a \orC is the one store in the Or
node itself.
In the case of a conjunction,
if the to-be-explored leaf in the lhs is \okC, then we look for 
the \getend in the rhs, otherwise we return the result of the lhs.

We derive the following two functions from \getend:

\mvspace{}
\defline[def:get_subst]{tex_code/get_subst.tex}
\defline[def:path_end]{tex_code/path_end.tex}


\mvspace{}
In \cref{tree-ex1} the \pathend of the tree is \eI{g X Y}.

\begin{figure}
  \begin{subfigure}{0.25\textwidth}
    \begin{center}\includestandalone[width=\textwidth]{./src/path2}\end{center}
    \caption{Path end := g X Y}
    \label{tree-ex1} 
  \end{subfigure}
  \begin{subfigure}{0.4\textwidth}
    \includestandalone[width=\textwidth]{./src/path_exp2}
    \caption{Step on g X Y using \cref{fig:prog}}
    \label{tree-ex1-exp} 
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \includestandalone[width=1\textwidth]{./src/tree_cut2}
    \caption{Scope of the cut}
    \label{cut-scope} 
  \end{subfigure}
\caption{Some tree representations} 
\end{figure}


Below we define three special kinds of trees depending on their \pathend.

\defline[def:success]{tex_code/succ_path.tex}
\defline[def:failed]{tex_code/failed_path.tex}
\defline[def:pathatom]{tex_code/path_atom.tex}

The latter definition identifies path ending in an atom.

\subsection{The \step procedure}

The \step procedure takes as input a program, a set of free variables (fv), a
substitution, and a tree, and returns an updated set of free variables, a
\steptag, and an updated tree.  

Free variables are those variables that appear in a tree; they are used and
updated when a backchaining operation takes place.

The \steptag (see~\cref{type:steptag}) indicates the kind of an internal tree step:
\cI{CutBrothers} denotes the interpretation of a superficial cut, i.e., a cut
whose parent nodes are all \andC-nodes. \cI{Expanded} denotes the interpretation
of non-superficial cuts or predicate calls. \cI{Failure} and \cI{Success} are
returned for, respectively, \failed and \success trees.


The step procedure is intended to interpretate atoms,
that is, it transforms the tree iff its \pathend is an atom,
otherwsise, it returnes the identity.

\mvspace{}
\deflemma[lemma:success]{tex_code/success_step.tex}
\deflemma[lemma:failed]{tex_code/failed_step.tex}
\mvspace{}

\textit{Call step} The interpretation of a call $c$ stars by calling the
\backchain function on $c$. The output list $l$ is taken to 
represent build the new subtree.
If $l$ is empty then \koC tree is returned, otherwise
the subtree is a right-skewed tree made of $n$ inner \orC nodes,
where $n$ is the length of $l$.
The root has \koC as left child. The lhs of the other nodes is a
right-skewed tree of \andC nodes. The \andC nodes are again a right-seked tree
containing premises of the selected rule \marginpar{dire dei reset point}.

A step in the tree of \cref{tree-ex1} makes a backchain operation over the query
\eI{g X Y} and, in the program defined in \cref{fig:prog}, the new tree would be the one in
\cref{tree-ex1-exp}. We have put a red border aroung the new generated subtree.
It is a disjunction of four subtrees:
the first node is the \koC node (by default), the second is \okC, since r1
has no premises, the third and the fourth contains the premises of respectively
$r_2$ and $r_3$. \marginpar{dire che le sostituzioni del backchain sono importanti e dove sono mess}

\textit{Cut step} The cut case is delicate, since interpreting a cut in a tree
has three main impacts: at first the cut is replaced by the \okC node, then
some special subtrees, in the scope of the \cutC, are cut away: in particular
we need to soft-kill the left-siblings of the \cutC and hard-kill the right-uncles
of the the \cutC.

\begin{definition}[Left-siblings (resp. right-sibling)]
  Given a node $A$, the left-siblings (resp. right-sibling) of $A$
  are the list of subtrees sharing the same parent of $A$ and that appear
  on its left (resp. right).
\end{definition}

\begin{definition}[Right-uncles]
  Given a node $A$, the right-uncles of $A$ are the list of right-sibling of the
  father of $A$.
\end{definition}

\begin{definition}[Hard-kill, \cutr]
  Given a tree $t$, hard-kill replaces the given subtree with the \koC node
\end{definition}

\begin{definition}[Soft-kill, \cutl]
  Given a successfull tree $t$, soft-kill replaces with \koC all subtrees
  that are not part of the path in $t$ leading to the \okC node.
\end{definition}


An example of the impact of the cut is show in \cref{cut-scope},
the dashed triangles represent generic trees. The step
routine interprets the cut since it is the node in its path-end:
we pass throgh a and and all trees on the left of the
cut are successful. In the example
we have $4$ arrow tagged with the \cutl or \cutr symbols. The \cutl arrows go
left and soft-kill the pointed subtree, it
keeps \okC nodes since they are part of the tree leading to the cut, and replaces
the other subtrees with \koC. The \cutr procedure replaces the nodes
pointed by the arrows with \koC.


\subsection{The \na procedure}

It is evident that the \step alone is not sufficient to reproduce entirely the
behavior of the full expected prolog interpreter. In particular, 
we need to bracktrack on failures. Moreover, in case of success,
we should return a state where the state in cleaned of the success itself,
this is essential to, non deterministically, find all the
solution of a given query.
By \cref{lemma:success,lemma:failed}, we know that \step returns the identity
on successful and failed states. In order
to continue the computation on these particular trees, we
need the \na procedure aiming to expecially work with
failed and successful trees:
and its implementation in \cref{fig:na}.

The \na procedure takes a boolean and a tree, clean it from failures
or success and returns a new tree if this tree still contains
a non explored path. The idea behind \na is to 
clean recursively every subtree in DFS order if its \pathend is
a failure. Moreover, if the boolean passed to \na is true, then it
erases the first successful path in the tree.

The base cases of \na are immidiate.
The \orC case is rathere intuitive: if the lhs of the \orC does
not exist we look for the \na in the rhs. Otherwise, we look for the \na
in the lhs, if this \na does not exists, we look for the \na in the rhs.

We want to spend few words about the \andC case, since the reset point $B0$
for $B$ plays an important role. 
The \na in an \andC tree should consider two cases: if the lhs succeeds, then
the \na should be retrived in the rhs. If this alternative does not exists
it means that the rhs has entirely been explored. We need to erase the success
in the lhs and try to find if a non-explored alternative exists. If so,
we return a new tree with the new lhs and the rhs is built from the reset point.
\cI{big_and} is a trivial function build a right-skewed tree of and nodes
where the leaves are the atoms written in the reset point.
We need to reuse the reset point since,
the step procedure in \andC trees
evaluates the rhs of a \andC tree if the lhs succeeds.
This evaluation is dependent on the subsitution in the lhs tree.
Therefore, if we need to backtrack in the lhs, we need to reset the
rhs.

Some interesting property of \na are shown below and allow to see how \na
complements \step.

\mvspace{}
\deflemma[lemma:pathna]{tex_code/path_atom_next_alt_id.tex}
\deflemma[lemma:nafailedf]{tex_code/na_failed.tex}
\mvspace{}



% that is it is allowed to transform \okC or \koC leaves into \deadC, so
% that the \step procedure is allowed to ignore the new ghosts states and move on.
% The boolean taken by \na tells if it is needed to kill \okC nodes or not.

For example, in \cref{tree-ex1-exp} the step procedure has created a failed
state: its path-end ends in \koC. The expected behavior of \na is to take
this \koC node and make it a .... This allows \step to continue the
exploration of the tree. In particular, the path-end of this new state end
in \okC. The step leaves the state unchanged producing the new substitution.\marginpar{subst taken form the or}
This solution however is not unique, we should be able to backtrack on this
successful state. To do so we can call \na and it will deadify the \okC node
allowing \step to proceed on r X Z.

\begin{figure}
  \input{tex_code/next_alt_code.tex}
  \caption{\na implementation}
  \label{fig:na}
\end{figure}



\subsection{The \run inductive}

The inductive procedure \run is modeled as a function: it takes as input a
program, a set of free variables, an initial substitution $\sigma_0$, and a tree
$t_0$, and returns a substitution $\sigma_1$ together with an optional updated
tree $t_1$. The substitution $\sigma_1$ represents the most-general unificator
that makes the execution of the tree $t_0$ succeed starting from the initial
substitution $\sigma_0$, $\sigma_1$ is an extension of $\sigma_0$.
The tree $t_1$ is the updated tree containing the alternatives that have
not yet been explored. If the tree contains no solution, then \texttt{None} is
returned.

The procedure \run is based on three main derivation rules, shown in
\cref{fig:run-rules}. If the \pathend of the tree $t$ is a success, the input
substitution is returned and the input tree is cleaned of its successful
path. If the \pathend of the tree is an atom, then \step is
invoked to evaluate this atom, and \run is recursively called on the new
tree. Finally, if the \pathend of the tree is a failure,
\na is called to clear the failed path; if the resulting cleaned tree
exists, \run is recursively called on it.
\begin{figure}[h]

  \input{tex_code/runbp.tex}
  % \begin{prooftree}
  %   \AxiomC{$\success\ A$}
  %   \RightLabel{$\run\_done$}
  %   \UnaryInfC{$\run\ fv\ s_1\ A\ (\getsubst\ s_1\ A)\ (\na\ \top\ A)$}
  % \end{prooftree}

  % \begin{prooftree}
  %   \AxiomC{$\pathatom\ A$}
  %   \AxiomC{$\step\ u\ p\ fv_0\ s_1\ A\ = (fv_1,\ st,\ B)$}
  %   \AxiomC{$\run\ fv_1\ s_1\ B\ s_2\ r$}
  %   \RightLabel{$\run\_step$}
  %   \TrinaryInfC{$\run\ fv_0\ s_1\ A\ s_2\ r$}
  % \end{prooftree}

  % \begin{prooftree}
  %   \AxiomC{$\failed\ A$}
  %   \AxiomC{$\na\ \bot\ A = \mathrm{Some}\ B$}
  %   \AxiomC{$\run\ fv_0\ s1\ B\ s_2\ r$}
  %   \RightLabel{$\run\_fail$}
  %   \TrinaryInfC{$\run\ fv_0\ s_1\ A\ s_2\ r$}
  % \end{prooftree}  

  \caption{Rule system for \run}
  \label{fig:run-rules}
\end{figure}

\section{\elpiP semantics}

We now want to introduce the elpi semantics. The interpreter we show reflects
the interpreter of the \elpiP language and is an operational semantics
close to the one picked by Pusch in \cite{10.1007/BFb0105415}, in turn
closely related to the one given by Debray and Mishra in
\cite[Section 4.3]{10.1016/0743-1066(88)90007-6}. Pusch mechanized
the semantics in Isabelle/HOL together with some optimizations that
are present in the Warren Abstract Machine~\cite{warren1983abstract,10.7551/mitpress/7160.001.0001}.

The inductive representing a state of the \elpiP language is shown below.

\input{tex_code/elpi_def.tex}

An elpi state is an enhanced two-dimension list. The outermost list represents
the list of alternatives in disjunction accompagnate with the substitution that
should be used to for their interpretation. The innermost list is a list of
atom, representing a list of goals in cunjunctions. These goals are decorated
with a pointer to an elpi state, and are used to keep trace of the alternatives
that should be kept when a cut is interpreted. We call these, special,
alternatives the cut-to alternatives.


% We are completely loosing the tree structure. There are no clean reset
% points. The backtracking operation is simpler: it is the tail function.
% The cutr and cutl operations disappears: the alternatives are stored 
% directly in the cutE terminal.
\begin{figure}
  \input{tex_code/stepE.tex}

  \mvspace{}
  \deftypes[type:nur]{tex_code/nur_type.tex}
  \mvspace{}

  \input{tex_code/nurbp.tex}

  \caption{Rule system for \nur}
  \label{fig:nur-rules}
\end{figure}

The idea of the \textsc{Elpi} interpreter is to receive a list of alternatives.
The first alternative consists of a list of goals. Four cases must be taken
into account; they are shown in \cref{fig:nur-rules}. In order to simplify goal
retrieval, we split the head of the alternatives from the tail, so that it can
be immediately matched in the inductive definition. Note that an empty list of
alternatives represents, by definition, a failing state. If the goal list is
empty (\textsc{StopE}), then we have, by definition, a success, and the input
solution together with the list of alternatives is returned. If the goal list
starts with a cut (\textsc{CutE}), then the current alternatives are erased in
favour of the cut alternatives, and a recursive call is made on the remaining
goal list.

Finally, we must consider the case in which the goal list starts with a call.
The call can either fail (\textsc{FailE}) or succeed (\textsc{CallE}). We
distinguish the two cases by looking if the backchaining operation returns
zero or more rules. We have wrapped this task in the \emph{stepE}
procedure, which also updates the goal and cut-alternative list. The fail case,
is relatively easy: the first goal does not
succeed, we need to take the head of the alternatives, and make it the new list
of goals to be explored.

The case in which backchaining produces a non empty list, the \emph{save\_alts}
routine is in cahrge of: taking the list of premises and add to each atom the
the list of alternatives $a$ as their new cut-alternatives, then it append the
list of goals $gl$ to each of these new lists.

\section{Semantic equivalence}

The equivalence between the two semantics is possible under two conditions: we
need to work with ``valid states'', i.e. all of those states that can be
generated from a call. Secondly, we need to translate trees state into elpi
states. In the next to subsection we propose the two functions \vast and \ttl.

\subsection{Valid trees}

The inductive tree allows one to generate a large number of
trees, some of which are not valid, in the sense that they cannot be produced
starting from a given query. The class of valid trees is characterized by the
function shown in \cref{fig:vt}.


While all base cases of tree are considered valid, we need to analyze 
carefully the cases for the \orC and \andC constructors.

For the \orC constructor, we distinguish two cases depending on whether the
left-hand side (lhs) exists. If it does not exist, then the right-hand side
(rhs) must be a valid tree. Otherwise, the lhs must itself be a valid tree,
and the rhs is either the \koC tree, since it may have been removed by the
evaluation of a superficial cut in the lhs, or it has not yet been explored.
In the latter case, it is a \cI{base_or} tree, namely the right-skewed tree
formed by a disjunction of conjunctions that is genereated after a
succeful backchain to a call.

For the \andC constructor, the lhs is required to be a valid tree. The shape
of the rhs depends on whether the lhs is a success. If the lhs is not
successful, then the rhs has never been explored: the procedures \step and
\na modify the rhs only when the lhs succeeds. In this case, the lhs must be
the right-skewed tree containing conjunctions of premises atoms,
the reset point $B_0$ ensure what shape the rhs should have. 
If the lhs is a success tree, then the rhs can be modified by \step and \na,
therefore it must be a valid tree.


\begin{figure}  

  \begin{subfigure}{0.44\textwidth}
    \input{tex_code/valid_tree.tex}
    \caption{Valid tree}
    \label{fig:vt}
  \end{subfigure}
  \begin{subfigure}{.55\textwidth}
    \input{tex_code/t2l.tex}
    \caption{Tree to list}
    \label{fig:ttl}
  \end{subfigure}
\caption{Valid tree and Tree to list}
\end{figure}

\subsection{From trees to lists}

The translation of a tree to a list is shown in \cref{fig:ttl}. It takes the
tree to be translated, a substitution (called $s$), a list of alternatives, called
\emph{bt}. The substitution $s$ tells what is the subsitution of the 
alternative we are building and is updated when going to the
rhs of the \orC constructor. The \emph{bt} list represents the alternatives 
of the right-sibling of the current subtree. They are useful to know if 
they should be added to the current goal as cut alternatives.

An \okC node represent a success in a tree, then the translation of this state
returns a singleton list with the cuple $(s, [::])$: there is one alternative
with $0$ goals, i.e. a success in elpi by \textsc{StopE}. The \koC node
represent a failure, and, therefore $0$ alternatives. An atom is translated into
a singleton with the atom as first goal and the empty cut-alternative list: we
are not adding $bt$ since they are the alternatives for the right-sibling, not
the right-uncles, this means that if we have $a$ is a cut, then it erases the
alternatives bt.

In a disjunction, we are scendendo di un livello the distance from our
backtracking list. This means that $bt$ becomes the list of right-uncles of the
two branches of the \orC constructor. The compilation of the rhs is done
independently of if the lhs exists: we transform the rhs into an elpi state and
passing the empty list of alternatives, since the rhs as no right-siblings.
Then, thanks to \texttt{add\_ca\_deep}, we recursively add $bt$ to every
cut-alternative appearing in the translated goals. If the lhs exists, we
translate it and pass the translation of the rhs as the list of right-siblings.
Then we prepend the translated lhs to the translated rhs and add $bt$ with
\texttt{add\_ca\_deep}.

We compile the \andC case by translating its lhs to the list $lA$ and reset
point to the list $lB0$. Then, thanks to \texttt{add\_deep}, we recrusively
append $lB0$ to the alternatives born in $lA$, i.e. we leave unchanged the
pointers to $bt$ if any in $lA$. The list 

Final

This translation may returns an empty list, this means there are no alternatives
in the lhs then, the rhs is usless and ignored. Otherwise, we have the list
$[::(s_0,gs) \& al]$. By the \run semantics, we know that the rhs of a \andC
stands for a list of alternatives that should be run only after the 
path atom 




% \newcommand{\thte}{\texttt{tree\_to\_elpi}} % theorem tree to elpi name
% \newcommand{\thet}{\texttt{elpi\_to\_tree}} % theorem elpi to tree name

\subsection{Equivalence theorems}

\mvspace{}
\deflemma[th:t1]{tex_code/tree_to_elpi.tex}

% \begin{theorem}[\thte]
% \begin{align*}
%   \forall A\ \sigma_1\ B\ \sigma_2\ b\ \sigma_0,
%   \vt\ A \to \\
%   \run_u\ \sigma_1\ A\ (Some\ \sigma_2)\ B\ b \to \\
%     \exists x\ xs, 
%       \ttl\ A\ \sigma_1\ \nilC = x ::: xs \land
%       \nur_u\ x.1\ x.2\ xs\ \sigma_2\ (\ttl\ B\ \sigma_0\ \nilC).
% \end{align*}

% \end{theorem}

\mvspace{}
\deflemma[th:t2]{tex_code/elpi_to_tree.tex}

\mvspace{}
% \begin{theorem}[\thet]
%   \label{thet}
% \begin{align*}
%   \forall \sigma_1\ \sigma_2\ a\ na\ g, \\
%   \nur_u\ \sigma_1\ g\ a\ \sigma_2\ na \to  \\
%   \forall \sigma_0\ t, \vt\ t \to (\ttl\ t\ \sigma_0\ \nilC) = ((\sigma_1,g) ::: a) \to \\
%   \exists t'\ n, \run_u\ \sigma_0\ t\ (Some\ \sigma_2)\ t'\ n \land \ttl\ t'\ \sigma_0\ \nilC = na.
% \end{align*}
% \end{theorem}

The proof of \cref{th:t2} is based on the idea explained in~\cite[Section
3.3]{yves-equiv}. An ideal statement for this lemma would be: given a function
\texttt{l2t} transforming an elpi state to a tree, we would have have that the
the execution of an elpi state $e$ is the same as executing \run on the tree
resulting from $\texttt{l2t}(e)$. However, it is difficult to retrive the
strucutre of an elpi state and create a tree from it. This is because, in an
elpi state, we have no clear information about the scope of an atom inside the
list and, therefore, no evident clue about where this atom should be place in
the tree. 

Our theorem states that, starting from a valid state $t$
which translates to a list of alternatives $(\sigma_1, g) :: a$.
If we run in elpi the list of alternatives, then the execution of the tree $t$
returns the same result as the execution in elpi. The proof is performed
by induction on the derivations of the elpi execution. We have $4$
derivations.

We have $4$ case to analyse:

% \begin{enumerate}
%   \item StopE: We have an empty list of goals, and therefore a success.\\
%         By the definition of \vt, we know that $\ttl t = 
% \end{enumerate}



% This means that multiple different (and non-equivalent) trees
% can be produced from a given elpi state.
% For example the elpi state $[[f X]; [g X]]$ could be represented by
% the tree $((Dead \lor f X) \lor g X)$




\begin{figure}
  \begin{center}
    \includestandalone[width=.2\textwidth]{src/e2t_ind}
  \end{center}
\caption{Induction scheme for \cref{th:t2}}  
\end{figure}

\section{Case study: determinacy alanysis}

we mechanize the first order part of xxx.

snippet det, main thm, invariant det tree (valid tree prev section?)

proof induciton on exec, step/next alt preserving invariant
proved by induction on the tree.

with list semantics cut and next alt requires to express
a link btween the ca or next alts and the current goal,
which is non trivial without an intermediate data
strature like the tree

\section{Related work}

prolog semantics, King lost

yves for the proof technique


\section{Conclusion}


\bibliography{bib}
\end{document}
