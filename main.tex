
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate, lineno]{lipics-v2021}

\usepackage{minted}
\usepackage{macro}
\usepackage{xspace}
%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle
\title{Dummy title} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Jane {Open Access}}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}

\authorrunning{J. Open Access and J.\,R. Public} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Dummy keyword} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
\end{abstract}

\section{Common code: the language}
\begin{minted}{coq}
Inductive Tm := 
  | Tm_Kp    : Kp -> Tm
  | Tm_Kd    : Kd -> Tm
  | Tm_V     : V  -> Tm
  | Tm_Comb  : Tm -> Tm -> Tm.

Inductive Callable := 
  | Callable_Kp   : Kp -> Callable
  | Callable_V    : V -> Callable
  | Callable_Comb : Callable -> Tm -> Callable.

Inductive RCallable := 
  | RCallable_Kp   : Kp -> RCallable
  | RCallable_Comb : RCallable -> Tm -> RCallable.
\end{minted}

A callable term is a term without a data constructor as functor.

An rcallable is a term with rigid head.

\begin{minted}{coq}
Inductive A := cut | call : Callable -> A.
\end{minted}

An atom is the smallest syntactic unit that can be executed in a prolog
program \program. The execution of an atom, inside a program and a substitution
either succeeds returining an output substitution, or it fails.
In both cases it returns a list of choice points, representing suspending
states that can be resumed for backtracking.

\begin{minted}{coq}
Record R := mkR { head : RCallable; premises : list A }.
\end{minted}

We exploit the typing system to ensure that the head of a "valid" rule
is a term with rigid head.

\begin{minted}{coq}
(*simpler than in the code: signatures of preds are hidden*)
Definition program := seq R. 
\end{minted}

A program is made by a list of rules. Rules in \program are indexed by their
position in the list. Given a list of rules \rules and two indexes $i$ and $j$,
s.t. $i\neq j$ then, $\rules_i$ has a higher priority then $\rules_j$.

Sigma is a substitution mapping variables to their term instantiation.
\begin{minted}{coq}
  Definition Sigma := {fmap V -> Tm}.
\end{minted}

The backchaining algorithm is the function \backchain aims to filter
only the rules in the program \program having rules unifying with the
current query $q$ in a given subtitution $\sigma$ using the list of modes $m$.
In particular \backchain returns for each selected rule $r$ a substitution
$\sigma'$ that is the substitution obtained by the unification of the query and
the head of $r$.

$$\backchain\ :\ (\program, \sigma, q) \to \texttt{seq}(\sigma * R)$$


\section{Semantics intro}

We propose two operational semantics for a logic program with cut. The two
semantics are based on different syntaxes, the first syntax (called tree)
exploits a tree-like structure and is ideal to have a graphical view of its
evaloution while the progrma is being intepreted. The second syntax is the
elpi's syntax, we call it therefore elpi. We aim to prove the equivalence of the
two semantics together with some interesting lemmas of the cut behavior.


\subsection{Tree semantics}
\input{tex_code/tree_def.tex}

In the tree we distinguish 6 main cases: Bot and OK are respectively the
standard fail $\bot$ and true $\top$ predicates of prolog. Dead is a special
symbol representing a ghost state, that is, a state useful to keep the
structure of a tree from an execution to another but that is completely ignored
by the intepretation of the program.

TA, standing for tree-atom, is a terminal of the tree containg an atom and a 
program. 

The two recursive cases of a tree are the Or and the And non-terinals. The Or
non-terminals $A \lor B_\sigma$ stands for a disjunction between two trees A and
B. The second tree branch is decorated with a suspended substituion $\sigma$ so
that, when we backtrack to $B$, we use $\sigma$ as initial substitution for $B$.

The And non-terminal $A \land_r B$ represents of a conjunction of two trees
$A$ and $B$. We call $r$ the reset-point and is used to resume the $B$ state in
its intial form if some backtracking operation is performed on $A$.

\begin{figure}
  \input{tex_code/step_tag.tex}
  \input{tex_code/step.tex}
\caption{Step for tree semantics}
\end{figure}

\begin{figure}
  \input{tex_code/next_alt.tex}
\caption{backtracking operation}
\end{figure}

The main 

The tree interpreter is made by two fixpoints and an inductive.


\marginpar{TODO: define path}
We make the distinction between some kind of particular trees:
\begin{enumerate}
  \item success is a tree with a successfull path
  \item failed is a tree with a failed path
  \item dead is a tree with deads states
\end{enumerate}



\begin{figure}  
\begin{minted}{coq}
Fixpoint valid_tree s :=
  match s with
  | TA _ _ | OK | Bot => true
  | Dead => false
  | Or A _ B => 
    if is_dead A then valid_tree B
    else valid_tree A && (bbOr B)
  | And A B0 B => 
    valid_tree A &&
      if success A then valid_tree B 
      else 
        let B' := big_and B0.1 B0.2 in
        B == B'
  end.
\end{minted}
\caption{Valid tree}
\end{figure}
\subsection{Elpi semantics}

The Elpi interpreter is based on an operational semantics
close to the one picked by Pusch in \cite{10.1007/BFb0105415}, in turn
closely related to the one given by Debray and Mishra in
\cite[Section 4.3]{10.1016/0743-1066(88)90007-6}. Push mechanized
the semantics in Isabelle/HOL together with some optimizations that
are present in the Warren Abstract Machine~\cite{warren1983abstract,10.7551/mitpress/7160.001.0001}.

In these operational semantics we need to decorate the cut
atom with a list of alternative, morally a pointer to a sub-list
of the overall alternatives. An atom in the elpi semantcis is defined as follows:

\begin{minted}{coq}
Inductive G := 
  | callE : program -> Callable -> G
  | cutE : alts -> G
with alts := Al of seq (seq G)
with goals := Gl of seq goals.
\end{minted}

We are completely loosing the tree structure. There are no clean reset
points. The backtracking operation is simpler: it is the tail function.
The cutr and cutl operations disappears: the alternatives are stored 
directly in the cutE terminal.

The elpi interpreter is as follows:
\begin{minted}{coq}
(*TODO: add system of rules*)
Inductive nur : Sigma -> goals ->  alts -> Sigma -> alts -> Type :=
  | StopE s a : nur s nilC a s a
  | CutE s s1 a ca r gl : nur s gl ca s1 r -> nur s ((cutE ca) ::: gl) a s1 r
  | CallE p s s1 a b bs gl r t : 
    F u p t s = [:: b & bs ] -> 
      nur b.1 (save_goals a gl (a2gs1 p b)) (save_alts a gl ((aa2gs p) bs) ++ a) s1 r -> 
        nur s ((callE p t) ::: gl) a s1 r
  | FailE p s s1 s2 t gl a al r : 
    F u p t s = [::] -> nur s1 a al s2 r -> nur s ((callE p t) ::: gl) ((s1, a) ::: al) s2 r.
\end{minted}


The translation of a tree to a list is as follows:

\begin{minted}{coq}
(*TODO: add notation for nilC which is [::]*)
Fixpoint t2l (A: tree) s (bt : alts) : alts :=
match A with
| OK => (s, nilC) ::: nilC
| Bot => nilC
| Dead => nilC
| TA _ cut => (s, ((cutE nilC) ::: nilC)) ::: nilC
| TA pr (call t) => (s, ((callE pr t) ::: nilC)) ::: nilC
| Or A s1 B => 
  let lB := t2l B s1 nilC in
  let lA := t2l A s lB in
  add_ca_deep bt (lA ++ lB)
| And A B0 B =>
  let hd  := r2l B0.1 B0.2 in
  let lA  := t2l A s bt in
  if lA is more_alt (slA, x) xs then 
      (* the reset point exists, it has to be added to all cut-to alternatives *)
      let xz := add_deepG bt hd x in
      let xs := add_deep bt hd xs in 
      (* each alt in xs must have hd has rightmost conjunct  *)
      let xs := make_lB0 xs hd in
      (* xs are alternatives that should be added in the deep cuts in B *)
      let lB   := t2l B slA (xs ++ bt) in
      (* lB are alternatives, each of them have x has head *)
      (make_lB01 lB xz) ++ xs
  else nilC
end.
\end{minted}


\begin{theorem}[tree\_to\_elpi]
\begin{align*}
  \forall A\ \sigma_1\ B\ \sigma_2\ b\ \sigma_0,
  \vt\ A \to \\
  \run_u\ \sigma_1\ A\ (Some\ \sigma_2)\ B\ b \to \\
    \exists x\ xs, 
      \ttl\ A\ \sigma_1\ \nilC = x ::: xs \land
      \nur_u\ x.1\ x.2\ xs\ \sigma_2\ (\ttl\ B\ \sigma_0\ \nilC).
\end{align*}

\end{theorem}

\begin{theorem}[elpi\_to\_tree]
\begin{align*}
  \forall \sigma_1\ \sigma_2\ a\ na\ g, \\
  \nur_u\ \sigma_1\ g\ a\ \sigma_2\ na \to  \\
  \forall \sigma_0\ t, \vt\ t \to (\ttl\ t\ \sigma_0\ \nilC) = ((\sigma_1,g) ::: a) \to \\
  \exists t'\ n, \run_u\ \sigma_0\ t\ (Some \sigma_2)\ t'\ n \land \ttl\ t'\ \sigma_0\ \nilC = na.
\end{align*}

\end{theorem}
\bibliography{bib}
\end{document}
