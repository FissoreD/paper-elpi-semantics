@article{DBLP:journals/cacm/Knuth74,
  author    = {Donald E. Knuth},
  title     = {{Computer Programming as an Art}},
  journal   = {Commun. {ACM}},
  volume    = {17},
  number    = {12},
  pages     = {667--673},
  year      = {1974},
  doi       = {10.1145/361604.361612},
  timestamp = {Tue, 07 Jun 2011 16:50:57 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Knuth74},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@article{DBLP:journals/cacm/Dijkstra68a,
  author    = {Edsger W. Dijkstra},
  title     = {Letters to the editor: go to statement considered harmful},
  journal   = {Commun. {ACM}},
  volume    = {11},
  number    = {3},
  pages     = {147--148},
  year      = {1968},
  doi       = {10.1145/362929.362947},
  timestamp = {Thu, 09 Feb 2006 13:19:49 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/cacm/Dijkstra68a},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@book{DBLP:books/mk/GrayR93,
  author    = {Jim Gray and
               Andreas Reuter},
  title     = {Transaction Processing: Concepts and Techniques},
  publisher = {Morgan Kaufmann},
  year      = {1993},
  isbn      = {1-55860-190-2},
  timestamp = {Thu, 05 Nov 2015 19:53:28 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/books/mk/GrayR93},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}



@inproceedings{DBLP:conf/focs/HopcroftPV75,
  author    = {{John E.} Hopcroft and
               {Wolfgang J.} Paul and
               {Leslie G.} Valiant},
  title     = {On Time versus Space and Related Problems},
  booktitle = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  pages     = {57--64},
  year      = {1975},
  crossref  = {DBLP:conf/focs/FOCS16},
  doi       = {10.1109/SFCS.1975.23},
  timestamp = {Tue, 16 Dec 2014 09:57:24 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/HopcroftPV75},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@proceedings{DBLP:conf/focs/FOCS16,
  title     = {16th Annual Symposium on Foundations of Computer Science, Berkeley,
               California, USA, October 13-15, 1975},
  publisher = {{IEEE} Computer Society},
  year      = {1975},
  timestamp = {Mon, 15 Dec 2014 18:48:44 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/focs/FOCS16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@InProceedings{10.1007/BFb0105415,
author="Pusch, Cornelia",
editor="Goos, Gerhard
and Hartmanis, Juris
and van Leeuwen, Jan
and von Wright, Joakim
and Grundy, Jim
and Harrison, John",
title="Verification of compiler correctness for the WAM",
booktitle="Theorem Proving in Higher Order Logics",
year="1996",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="347--361",
abstract="Relying on an derivation of the Warren Abstract Machine (WAM) by stepwise refinement of Prolog models by B{\"o}rger and Rosenzweig we present a formalization of an operational semantics for Prolog. Then we develop four refinement steps towards the Warren Abstract Machine (WAM). The correctness and completeness proofs for each step have been elaborated with the theorem prover Isabelle using the logic HOL.",
isbn="978-3-540-70641-0"
}


@article{10.1016/0743-1066(88)90007-6,
author = {Debray, Saumya K. and Mishra, Prateek},
title = {Denotational and operational semantics for Prolog},
year = {1988},
issue_date = {March 1988},
publisher = {Elsevier Science Inc.},
address = {USA},
volume = {5},
number = {1},
issn = {0743-1066},
url = {https://doi.org/10.1016/0743-1066(88)90007-6},
doi = {10.1016/0743-1066(88)90007-6},
journal = {J. Log. Program.},
month = mar,
pages = {61–91},
numpages = {31}
}


@book{10.7551/mitpress/7160.001.0001,
    author = {Aït-Kaci, Hassan},
    title = {Warren's Abstract Machine: A Tutorial Reconstruction},
    publisher = {The MIT Press},
    year = {1991},
    month = {08},
    abstract = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.Contents Introduction • Unification—Pure and Simple • Flat Resolution • Prolog • Optimizing the Design • Conclusion • Appendixes},
    isbn = {9780262255585},
    doi = {10.7551/mitpress/7160.001.0001},
    url = {https://doi.org/10.7551/mitpress/7160.001.0001},
}



@techreport{warren1983abstract,
  added-at = {2025-05-25T19:33:51.000+0200},
  address = {Menlo Park, CA, USA},
  author = {Warren, David H.D.},
  biburl = {https://www.bibsonomy.org/bibtex/24df70a7f750e7f3626b0a0decb9f9449/gron},
  institution = {SRI International, Artificial Intelligence Center, Computer Science and Technology Division},
  interhash = {eda5ba9ff69c1ceb5a5e823d50f2e20e},
  intrahash = {4df70a7f750e7f3626b0a0decb9f9449},
  keywords = {AbstractMachine Prolog WAM},
  month = {October},
  number = {Technical Note 309},
  timestamp = {2025-05-25T19:33:51.000+0200},
  title = {{An Abstract Prolog Instruction Set}},
  url = {https://www.sri.com/wp-content/uploads/2021/12/641.pdf},
  year = 1983
}


@techreport{yves-equiv,
  author        = {Yves Bertot},
  title         = {A certified Compiler for an Imperative Language},
  number        = {RR-3488},
  institution   = {INRIA},
  month         = {September},
  year          = {1998},
  pages         = {30},
  url           = {https://inria.hal.science/inria-00073199v1},
}
@inproceedings{1990Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  xeditor    = {Rovan, Branislav},
  title     = {Retractions in comparing prolog semantics},
  booktitle = {Mathematical Foundations of Computer Science},
  year      = {1990},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {180--186},
  abstract  = {We present an operational model O and a continuation based denotational model D for a uniform variant of Prolog, including the cut operator. The two semantical definitions make use of higher order transformations $\Phi$ and $\Psi$, respectively. We prove O and D equivalent in a novel way by comparing yet another pair of higher order transformations $\Phi$ and $\Psi$, that yield $\Phi$ and $\Psi$, respectively, by application of a suitable abstraction operator.},
  isbn      = {978-3-540-47185-1}
}

@inproceedings{1989Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  editor    = {D{\'i}az, Josep
               and Orejas, Fernando},
  title     = {Continuation semantics for PROLOG with cut},
  booktitle = {TAPSOFT '89},
  year      = {1989},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {178--192},
  abstract  = {We present a denotational continuation semantics for PROLOG with cut. First a uniform language ℬ is studied, which captures the control flow aspects of PROLOG. The denotational semantics for ℬ is proven equivalent to a transition system based operational semantics. The congruence proof relies on the representation of the operational semantics as a chain of approximations and on a convenient induction principle. Finally, we interpret the abstract language ℬ such that we obtain equivalent denotational and operational models for PROLOG itself.},
  isbn      = {978-3-540-46116-6}
}

@phdthesis{qi2009,
  title         = {An Implementation of the Language Lambda Prolog Organized around Higher-Order Pattern Unification},
  author        = {Xiaochu Qi},
  year          = {2009},
  eprint        = {0911.5203},
  archiveprefix = {arXiv},
  booktitle = {PhD thesis},
  primaryclass  = {cs.PL},
  school = {Graduate School of the University of Minnesota},
  url           = {https://arxiv.org/abs/0911.5203}
}

@inproceedings{2003Andrews,
  author     = {Andrews, James H.},
  title      = {The witness properties and the semantics of the Prolog cut},
  year       = {2003},
  issue_date = {January 2003},
  publisher  = {Cambridge University Press},
  xaddress    = {USA},
  volume     = {3},
  number     = {1},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068402001540},
  doi        = {10.1017/S1471068402001540},
  abstract   = {The semantics of the Prolog ‘cut’ construct is explored in the context of some desirable properties of logic programming systems, referred to as the witness properties. The witness properties concern the operational consistency of responses to queries. A generalization of Prolog with negation as failure and cut is described, and shown not to have the witness properties. A restriction of the system is then described, which preserves the choice and first-solution behaviour of cut but allows the system to have the witness properties. The notion of cut in the restricted system is more restricted than the Prolog hard cut, but retains the useful first-solution behaviour of hard cut, not retained by other proposed cuts such as the ‘soft cut’. It is argued that the restricted system achieves a good compromise between the power and utility of the Prolog cut and the need for internal consistency in logic programming systems. The restricted system is given an abstract semantics, which depends on the witness properties; this semantics suggests that the restricted system has a deeper connection to logic than simply permitting some computations which are logical. Parts of this paper appeared previously in a different form in the Proceedings of the 1995 International Logic Programming Symposium (Andrews, 1995).},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {1–59},
  numpages   = {59},
  keywords   = {abstract semantics, cut, depth-first search, negation as failure, operational semantics}
}

@inproceedings{1996Somogy,
  title    = {The execution algorithm of mercury, an efficient purely declarative logic programming language},
  journal  = {The Journal of Logic Programming},
  volume   = {29},
  number   = {1},
  pages    = {17-64},
  year     = {1996},
  note     = {High-Performance Implementations of Logic Programming Systems},
  issn     = {0743-1066},
  doi      = {https://doi.org/10.1016/S0743-1066(96)00068-4},
  url      = {https://www.sciencedirect.com/science/inproceedings/pii/S0743106696000684},
  author   = {Zoltan Somogyi and Fergus Henderson and Thomas Conway},
  abstract = {We introduce Mercury, a new purely declarative logic programming language designed to provide the support that groups of application programmers need when building large programs. Mercury's strong type, mode, and determinism systems improve program reliability by catching many errors at compile time. We present a new and relatively simple execution model that takes advantage of the information these systems provide, yielding very efficient code. The Mercury compiler uses this execution model to generate portable C code. Our benchmarking shows that the code generated by our implementation is significantly faster than the code generated by mature optimizing implementations of other logic programming languages.}
}

@inproceedings{1989Warren,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jul,
  pages      = {451–481},
  numpages   = {31}
}

@inproceedings{1991Sahlin,
  author     = {Sahlin, Dan},
  title      = {Determinacy analysis for full Prolog},
  year       = {1991},
  issue_date = {Sept. 1991},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {26},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/115866.115869},
  doi        = {10.1145/115866.115869},
  journal    = {SIGPLAN Not.},
  month      = may,
  pages      = {23–30},
  numpages   = {8}
}

@inproceedings{1996mogensen,
  author    = {Mogensen, Torben \AE{}.},
  title     = {A Semantics-Based Determinacy Analysis for Prolog with Cut},
  year      = {1996},
  isbn      = {3540620648},
  publisher = {Springer-Verlag},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of the Second International Andrei Ershov Memorial Conference on Perspectives of System Informatics},
  pages     = {374–385},
  numpages  = {12}
}

@inproceedings{king2005,
  author  = {Lu, Lunjin and King, Andy},
  year    = {2005},
  month   = {04},
  pages   = {108-123},
  title   = {Determinacy Inference for Logic Programs},
  volume  = {3444},
  isbn    = {978-3-540-25435-5},
  journal = {Lecture Notes in Computer Science},
  doi     = {10.1007/978-3-540-31987-0_9}
}

@inproceedings{king2006,
  author    = {King, Andy
               and Lu, Lunjin
               and Genaim, Samir},
  editor    = {Etalle, Sandro
               and Truszczy{\'{n}}ski, Miros{\l}aw},
  title     = {Detecting Determinacy in Prolog Programs},
  booktitle = {Logic Programming},
  year      = {2006},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {132--147},
  abstract  = {In program development it is useful to know that a call to a Prolog program will not inadvertently leave a choice-point on the stack. Determinacy inference has been proposed for solving this problem yet the analysis was found to be wanting in that it could not infer determinacy conditions for programs that contained cuts or applied certain tests to select a clause. This paper shows how to remedy these serious deficiencies. It also addresses the problem of identifying those predicates which can be rewritten in a more deterministic fashion. To this end, a radically new form of determinacy inference is introduced, which is founded on ideas in ccp, that is capable of reasoning about the way bindings imposed by a rightmost goal can make a leftmost goal deterministic.},
  isbn      = {978-3-540-36636-2}
}


@inproceedings{2011king,
  title     = {RedAlert: Determinacy inference for Prolog},
  author    = {Kriener, Jael and King, Andy},
  journal   = {Theory and Practice of Logic Programming},
  volume    = {11},
  number    = {4-5},
  pages     = {537--553},
  year      = {2011},
  publisher = {Cambridge University Press}
}

@inproceedings{1996henderson,
  author = {Henderson, Fergus and Somogyi, Zoltan and Conway, Thomas},
  year   = {1996},
  month  = {08},
  booktitle = {Proceedings of Australian Computer Science Conference},
  pages  = {337-346},
  title  = {Determinism analysis in the Mercury compiler}
}

@inproceedings{1987vanroy,
  title        = {Improving the execution speed of compiled Prolog with modes, clause selection, and determinism},
  author       = {Van Roy, Peter and Demoen, Bart and Willems, Yves D},
  booktitle    = {TAPSOFT'87: Proceedings of the International Joint Conference on Theory and Practice of Software Development Pisa, Italy, March 23--27, 1987 2},
  pages        = {111--125},
  year         = {1987},
  organization = {Springer}
}

@inproceedings{2002overton,
  author    = {Overton, David and Somogyi, Zoltan and Stuckey, Peter J.},
  title     = {Constraint-based mode analysis of mercury},
  year      = {2002},
  isbn      = {1581135289},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/571157.571169},
  doi       = {10.1145/571157.571169},
  abstract  = {Recent logic programming languages, such as Mercury and HAL, require type, mode and determinism declarations for predicates. This information allows the generation of efficient target code and the detection of many errors at compile-time. Unfortunately, mode checking in such languages is difficult. One of the main reasons is that, for each predicate mode declaration, the compiler is required to decide which parts of the procedure bind which variables, and how conjuncts in the predicate definition should be re-ordered to enforce this behaviour. Current mode checking systems limit the possible modes that may be used because they do not keep track of aliasing information, and have only a limited ability to infer modes, since inference does not perform reordering. In this paper we develop a mode inference system for Mercury based on mapping each predicate to a system of Boolean constraints that describe where its variables can be produced. This allows us handle programs that are not supported by the existing system.},
  booktitle = {Proceedings of the 4th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  pages     = {109–120},
  numpages  = {12},
  keywords  = {Boolean constraints, mode analysis, modes},
  location  = {Pittsburgh, PA, USA},
  series    = {PPDP '02}
}

@inproceedings{1994apt-oc,
  author     = {Apt, Krzysztof R. and Pellegrini, Alessandro},
  title      = {On the occur-check-free PROLOG programs},
  year       = {1994},
  issue_date = {May 1994},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {16},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/177492.177673},
  doi        = {10.1145/177492.177673},
  abstract   = {In most PROLOG implementations, for efficiency occur-check is omitted from the unification algorithm. This paper provides natural syntactic conditions that allow the occur-check to be safely omitted. The established results apply to most well-known PROLOG programs, including those that use difference lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs, we show their usefulness for proving absence of floundering. Finally, we propose a program transformation that transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = may,
  pages      = {687–726},
  numpages   = {40},
  keywords   = {PROLOG programs, moded programs, occur-check problem, unification algorithm}
}

@inproceedings{1996pfenning,
  author    = {Rohwedder, Ekkehard
               and Pfenning, Frank},
  editor    = {Nielson, Hanne Riis},
  title     = {Mode and termination checking for higher-order logic programs},
  booktitle = {Programming Languages and Systems --- ESOP '96},
  year      = {1996},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {296--310},
  abstract  = {We consider how mode (such as input and output) and termination properties of typed higher-order constraint logic programming languages may be declared and checked effectively. The systems that we present have been validated through an implementation and numerous case studies.},
  isbn      = {978-3-540-49942-8}
}

@inproceedings{tassi2018,
  title       = {{Elpi: an extension language for Coq (Metaprogramming Coq in the Elpi $\lambda$Prolog dialect)}},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01637063},
  booktitle   = {{The Fourth International Workshop on Coq for Programming Languages}},
  xaddress     = {Los Angeles (CA), United States},
  year        = {2018},
  month       = Jan,
  keywords    = {Coq ; $\lambda$Prolog ; metaprogramming ; extension language},
  pdf         = {https://inria.hal.science/hal-01637063v1/file/coqpl2018.pdf},
  hal_id      = {hal-01637063},
  hal_version = {v1}
}

@inproceedings{tassi2019,
  title       = {Deriving proved equality tests in {C}oq-{E}lpi},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01897468},
  booktitle   = {Proceedings of ITP},
  xaddress     = {Portland, United States},
  year        = {2019},
  month       = Sep,
  series =      {LIPIcs},
  pages =	{29:1--29:18},
  volume =	{141},
  doi         = {10.4230/LIPIcs.CVIT.2016.23},
  keywords    = {Induction ; Coq ; Equality test ; Parametricity translation ; Containers},
  pdf         = {https://inria.hal.science/hal-01897468v2/file/induction.pdf},
  hal_id      = {hal-01897468},
  hal_version = {v2}
}

@inproceedings{tassi2023,
  author    = {Gr\'{e}goire, Benjamin and L\'{e}chenet, Jean-Christophe and Tassi, Enrico},
  title     = {Practical and Sound Equality Tests, Automatically},
  year      = {2023},
  isbn      = {9798400700262},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3573105.3575683},
  doi       = {10.1145/3573105.3575683},
  abstract  = {In this paper we describe the design and implementation of feqb, a tool that synthesizes sound equality tests for inductive data types in the dependent type theory of the Coq system. Our procedure scales to large inductive data types, as in hundreds of constructors, since the terms and proofs it synthesizes are linear in the size of the inductive type. Moreover it supports some forms of dependently typed arguments and sigma types pairing data with proofs of decidable properties. Finally feqb handles deeply nested containers without requiring any human intervention.},
  booktitle = {Proceedings of CPP},
  xbooktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages     = {167–181},
  numpages  = {15},
  keywords  = {program synthesis, decision procedure, computational complexity, Elpi, Coq},
  xlocation  = {Boston, MA, USA},
  xseries    = {CPP 2023}
}

@inproceedings{fissore2023,
  title       = {{A new Type-Class solver for Coq in Elpi}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-04467855},
  booktitle   = {{The Coq Workshop}},
  xaddress     = {Bialystok, Poland},
  year        = {2023},
  month       = Jul,
  keywords    = {type classes ; coq ; lambda-prolog},
  pdf         = {https://inria.hal.science/hal-04467855v1/file/coq2023_TC-elpi.pdf},
  hal_id      = {hal-04467855},
  hal_version = {v1}
}

@inproceedings{Fissore2024,
author = {Fissore, Davide and Tassi, Enrico},
title = {Higher-Order unification for free!: Reusing the meta-language unification for the object language},
year = {2024},
isbn = {9798400709692},
publisher = {ACM},
xaddress = {New York, NY, USA},
url = {https://doi.org/10.1145/3678232.3678233},
doi = {10.1145/3678232.3678233},
abstract = {Specifying and implementing a proof system from scratch requires significant effort. Logical Frameworks and Higher Order Logic Programming Languages provide dedicated, high-level meta languages to facilitate this task in two ways: 1) variable binding and substitution are for free when meta language binders represent object logic ones; 2) proof construction, and proof search, are greatly simplified by leveraging the unification procedure provided by the meta language. Notable examples of meta languages are Elf [21], Twelf [23], λ Prolog [16], Beluga [24], Abella [8] and Isabelle [31] which have been used to implement or specify many formal systems such as First Order Logic [5], Set Theory [20], Higher Order Logic [19], and the Calculus of Constructions [4]. The object logic we are interested in is Coq’s type theory [28]. We aim to develop a higher-order unification-based proof search procedure using the meta language Elpi [3], a dialect of λ Prolog. Elpi’s equational theory includes βη -equivalence and features a higher-order unification procedure ≃ m for the pattern fragment [15]. Elpi offers an encoding of Coq terms that is suitable for meta programming [6, 9, 26, 27] but that restricts ≃ m to first-order unification problems only. We refer to this basic encoding as <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 1</AltText><File name="ppdp2024-1-inline1" type="svg"/></Formula>. In this paper we translate unification problems in <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 2</AltText><File name="ppdp2024-1-inline2" type="svg"/></Formula> to an alternative encoding called <Formula format="inline"><TexMath><?TeX $mathcal {M}$?></TexMath><AltText>Math 3</AltText><File name="ppdp2024-1-inline3" type="svg"/></Formula>, from which we derive ≃ o, the higher-order unification procedure of <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 4</AltText><File name="ppdp2024-1-inline4" type="svg"/></Formula>. ≃ o honours βη -equivalence for terms within the pattern fragment, and allows for the use of heuristics when the terms fall outside the pattern fragment. Moreover, as ≃ o delegates most of the work to ≃ m, it can be used to efficiently simulate a logic program in <Formula format="inline"><TexMath><?TeX $mathcal {O}$?></TexMath><AltText>Math 5</AltText><File name="ppdp2024-1-inline5" type="svg"/></Formula> by taking advantage of unification-related optimizations of the meta language, such as clause indexing.},
booktitle = {Proceedings of PPDP},
articleno = {3},
pages = {1-13},
keywords = {Higher-Order Unification, Logic Programming, Meta-Programming},
xlocation = {Milano, Italy},
xseries = {PPDP '24}
}
@book{1991ait-wam,
  author    = {Aït-Kaci, Hassan},
  title     = {Warren's Abstract Machine: A Tutorial Reconstruction},
  publisher = {The MIT Press},
  year      = {1991},
  month     = {08},
  abstract  = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.Contents Introduction • Unification—Pure and Simple • Flat Resolution • Prolog • Optimizing the Design • Conclusion • Appendixes},
  isbn      = {9780262255585},
  doi       = {10.7551/mitpress/7160.001.0001},
  url       = {https://doi.org/10.7551/mitpress/7160.001.0001}
}


@inproceedings{1991miller-pf,
  author    = {Miller, Dale},
  xeditor    = {Schroeder-Heister, Peter},
  title     = {A logic programming language with lambda-abstraction, function variables, and simple unification},
  booktitle = {Extensions of Logic Programming},
  year      = {1991},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {253--281},
  abstract  = {It has been argued elsewhere that a logic programming language with function variables and $\lambda$-abstractions within terms makes a very good meta-programming language, especially when an object language contains notions of bound variables and scope. The $\lambda$Prolog logic programming language and the closely related Elf and Isabelle systems provide meta-programs with both function variables and $\lambda$-abstractions by containing implementations of higher-order unification. In this paper, we present a logic programming language, called L$\lambda$, that also contains both function variables and $\lambda$-abstractions, but certain restriction are placed on occurrences of function variables. As a result, an implementation of L$\lambda$ does not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using L$\lambda$ as a meta-programming language are presented.},
  isbn      = {978-3-540-46879-0}
}

@techreport{1992nadathur,
author = {Nadathur, Gopalan and Pfenning, Frank},
title = {The Type System of a Higher-Order Logic Programming Language},
year = {1992},
note = {Duke University},
xaddress = {USA},
abstract = {The type system of the logic programming language $lambda$Prolog is discussed. The incorporation of higher-order notions within this language requires the use of a typing scheme to distinguish between expressions of different function types. Thus $lambda$Prolog is a (strongly) typed language, in contrast to the typeless language that underlies the idea of descriptive types in logic programming. The typing discipline that is employed in the language is based on the notion of simple types in the $lambda$-calculus. This form of typing enforces arity restrictions on functions and predicates and provides a builtin functional hierarchy over terms. The language contains a facility for defining new primitive types and thus permits finer grained distinctions to be introduced by the user. Further, the use of type variables and type constructors provides a form of polymorphism that is similar in certain respects to that present in the language ML. The notion of type checking in $lambda$Prolog is discussed and shown to be an operation that can be performed at the time of compilation. The value of typing distinctions in determining the clarity of programs and their usefulness in conjunction with type checking in preventing run-time errors due to type violations is also discussed. In addition to their function in type checking, types also have a major role in determining computations in the logic programming context. We discuss this aspect of types that is in contrast to their behavior in other programming paradigms and we show how this leads to a presence of types in the runtime environment. While typing has several advantages, it is sometimes to the programmer''s advantage to be able to omit their mention. Type reconstruction provides a means for filling missing type information in and we discuss issues pertinent to this process in the context of $lambda$Prolog.}
}

@inproceedings{1988pfenning,
  author    = {Pfenning, F. and Elliott, C.},
  title     = {Higher-order abstract syntax},
  year      = {1988},
  isbn      = {0897912691},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/53990.54010},
  doi       = {10.1145/53990.54010},
  abstract  = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
  booktitle = {Proceedings of PLDI},
  pages     = {199–208},
  numpages  = {10},
  location  = {Atlanta, Georgia, USA},
  xseries    = {PLDI '88}
}

@InProceedings{cohen_et_al:LIPIcs.FSCD.2020.34,
  author =      {Cohen, Cyril and Sakaguchi, Kazuhiko and Tassi, Enrico},
  title =       {{Hierarchy Builder: Algebraic hierarchies Made Easy in Coq with Elpi}},
  booktitle =   {Proceedings of FSCD},
  pages =       {34:1--34:21},
  series =      {LIPIcs},
  ISBN =        {978-3-95977-155-9},
  ISSN =        {1868-8969},
  year =        {2020},
  volume =      {167},
  xeditor =      {Ariola, Zena M.},
  xpublisher =   {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  xaddress =     {Dagstuhl, Germany},
  URL =         {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2020.34},
  URN =         {urn:nbn:de:0030-drops-123562},
  doi =         {10.4230/LIPIcs.FSCD.2020.34},
  annote =      {Keywords: Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, \lambdaProlog},
}

@book{Miller_Nadathur_2012,
  place={Cambridge},
  title={Programming with Higher-Order Logic},
  publisher={Cambridge University Press},
  author={Miller, Dale and Nadathur, Gopalan},
  year={2012}
}


@InProceedings{dunchev15lpar,
  author =       "Cvetan Dunchev and Ferruccio Guidi and Claudio Sacerdoti Coen and Enrico Tassi",
  title =        "{ELPI:} Fast, Embeddable, $\lambda${Prolog} Interpreter",
  booktitle =    "Proceedings of LPAR",
  xeditor =       "Martin Davis and Ansgar Fehnker and Annabelle McIver and Andrei Voronkov",
  series =       "LNCS",
  publisher="Springer",
  volume =       "9450",
  pages =        "460--468",
  year =         "2015",
  URL =          "https://inria.hal.science/hal-01176856v1",
  doi =          "10.1007/978-3-662-48899-7\_32",
}


@inproceedings{TASSI_2019,
  title     = {Implementing type theory in higher order constraint logic programming},
  author    = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  journal   = {Mathematical Structures in Computer Science},
  booktitle   = {Mathematical Structures in Computer Science},
  volume    = {29},
  xnumber    = {8},
  pages     = {1125--1150},
  year      = {2019},
  publisher = {Cambridge University Press},
  DOI={10.1017/S0960129518000427},
}

@inproceedings{Miller2018MechanizedMR,
  title={Mechanized Metatheory Revisited},
  author={Dale A. Miller},
  journal={Journal of Automated Reasoning},
  booktitle={Journal of Automated Reasoning},
  year={2018},
  volume={63},
  pages={625-665},
  publisher="Springer",
}

@inproceedings{wadler1996-hs,
  author     = {Hall, Cordelia V. and Hammond, Kevin and Peyton Jones, Simon L. and Wadler, Philip L.},
  title      = {Type classes in Haskell},
  year       = {1996},
  issue_date = {March 1996},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {18},
  number     = {2},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/227699.227700},
  doi        = {10.1145/227699.227700},
  abstract   = {This article defines a set of type inference rules for resolving overloading introduced by type classes, as used in the functional programming language Haskell. Programs including type classes are transformed into ones which may be typed by standard Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to Haskell programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the transformed program.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = mar,
  pages      = {109–138},
  numpages   = {30},
  keywords   = {Haskell, functional programming, type classes, types}
}


@InProceedings{sozeau2008-tc,
author="Sozeau, Matthieu and Oury, Nicolas",
title="First-Class Type Classes",
booktitle="Proceedings of TPHOLs",
year="2008",
publisher="Springer",
  series =       "LNCS",
  volume = {5170},
xaddress="Berlin, Heidelberg",
pages="278--293",
abstract="Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.",
isbn="978-3-540-71067-7"
}


@inproceedings{nakamura1986,
  author    = {Nakamura, Katsuhiko},
  title     = {Control of Logic Program Execution Based on the Functional Relations},
  year      = {1986},
  isbn      = {3540164928},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of ICLP},
  pages     = {505–512},
  numpages  = {8}
}

@inproceedings{wadler1989,
  author    = {Wadler, Philip},
  title     = {Theorems for free!},
  year      = {1989},
  isbn      = {0897913280},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/99370.99404},
  doi       = {10.1145/99370.99404},
  booktitle = {Proceedings of FPCA},
  pages     = {347–359},
  numpages  = {13},
  xlocation  = {Imperial College, London, United Kingdom},
  series    = {FPCA '89}
}

@InProceedings{Trocq,
author="Cohen, Cyril
and Crance, Enzo
and Mahboubi, Assia",
editor="Weirich, Stephanie",
title="Trocq: Proof Transfer for Free, With or Without Univalence",
booktitle="Programming Languages and Systems",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="239--268",
abstract="This article presents Trocq, a new proof transfer framework for dependent type theory. Trocq is based on a novel formulation of type equivalence, used to generalize the univalent parametricity translation. This framework takes care of avoiding dependency on the axiom of univalence when possible, and may be used with more relations than just equivalences. We have implemented a corresponding plugin for the Coq interactive theorem prover, in the Coq-Elpi meta-language.",
isbn="978-3-031-57262-3"
}

@phdthesis{enzo,
  title        = {Meta-Programming for Proof Transfer in Dependent Type Theory},
  author       = {Enzo Crance},
  year         = 2023,
  month        = {December},
  address      = {Nantes},
  note         = {Available at \url{https://ecrance.net/files/thesis-Enzo-Crance-en-light.pdf}},
  school       = {University of Nantes},
  type         = {PhD thesis}
}

@inproceedings{Trakt,
  author       = {Valentin Blot and
                  Denis Cousineau and
                  Enzo Crance and
                  Louise Dubois de Prisque and
                  Chantal Keller and
                  Assia Mahboubi and
                  Pierre Vial},
  editor       = {Robbert Krebbers and
                  Dmitriy Traytel and
                  Brigitte Pientka and
                  Steve Zdancewic},
  title        = {Compositional Pre-processing for Automated Reasoning in Dependent
                  Type Theory},
  booktitle    = {Proceedings of the 12th {ACM} {SIGPLAN} International Conference on
                  Certified Programs and Proofs, {CPP} 2023, Boston, MA, USA, January
                  16-17, 2023},
  pages        = {63--77},
  publisher    = {{ACM}},
  year         = {2023},
  url          = {https://doi.org/10.1145/3573105.3575676},
  doi          = {10.1145/3573105.3575676},
  timestamp    = {Tue, 07 Mar 2023 15:01:48 +0100},
  biburl       = {https://dblp.org/rec/conf/cpp/Blot0CPKMV23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@book{mcb,
  author       = {Assia Mahboubi and
                  Enrico Tassi},
  title        = {Mathematical Components},
  publisher    = {Zenodo},
  year         = 2022,
  month        = sep,
  doi          = {10.5281/zenodo.7118596},
  url          = {https://doi.org/10.5281/zenodo.7118596},
  keywords = "inria:book",
}
@InProceedings{krebbers25,
  author =	{Krebbers, Robbert and van der Maas, Luko and Tassi, Enrico},
  title =	{{Inductive Predicates via Least Fixpoints in Higher-Order Separation Logic}},
  booktitle =	{16th International Conference on Interactive Theorem Proving (ITP 2025)},
  pages =	{27:1--27:21},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-396-6},
  ISSN =	{1868-8969},
  year =	{2025},
  volume =	{352},
  editor =	{Forster, Yannick and Keller, Chantal},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2025.27},
  URN =		{urn:nbn:de:0030-drops-246258},
  doi =		{10.4230/LIPIcs.ITP.2025.27},
  annote =	{Keywords: Separation Logic, Program Verification, Data Structures, Iris, Rocq prover}
}

@inproceedings{hanus2025,
  author    = {Hanus, Michael and Prott, Kai-Oliver},
  title     = {{Determinism Types for Functional Logic Programming}},
  booktitle = {Proceedings of PPDP},
  pages     = {47--59},
  xseries = {PPDP '25},
  year = {2025}
}

@inproceedings{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13,
  author       = {Georges Gonthier and
                  Andrea Asperti and
                  Jeremy Avigad and
                  Yves Bertot and
                  Cyril Cohen and
                  Fran{\c{c}}ois Garillot and
                  St{\'{e}}phane Le Roux and
                  Assia Mahboubi and
                  Russell O'Connor and
                  Sidi Ould Biha and
                  Ioana Pasca and
                  Laurence Rideau and
                  Alexey Solovyev and
                  Enrico Tassi and
                  Laurent Th{\'{e}}ry},
  editor       = {Sandrine Blazy and
                  Christine Paulin{-}Mohring and
                  David Pichardie},
  title        = {A Machine-Checked Proof of the Odd Order Theorem},
  booktitle    = {Interactive Theorem Proving - 4th International Conference, {ITP}
                  2013, Rennes, France, July 22-26, 2013. Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {7998},
  pages        = {163--179},
  publisher    = {Springer},
  year         = {2013},
  url          = {https://inria.hal.science/hal-00816699v1},
  doi          = {10.1007/978-3-642-39634-2_14},
  timestamp    = {Sat, 30 Sep 2023 01:00:00 +0200},
  biburl       = {https://dblp.org/rec/conf/itp/GonthierAABCGRMOBPRSTT13.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org},
    keywords = "inria:paper, inria:proud",

}

@techreport{gonthier:hal-04034866,
  TITLE = {{A computer-checked proof of the Four Color Theorem}},
  AUTHOR = {Gonthier, Georges},
  URL = {https://inria.hal.science/hal-04034866},
  INSTITUTION = {{Inria}},
  YEAR = {2023},
  MONTH = Mar,
  PDF = {https://inria.hal.science/hal-04034866v1/file/FINALA%20computer-checked%20proof%20of%20the%20four%20color%20theorem%20-%20HAL.pdf},
  HAL_ID = {hal-04034866},
  HAL_VERSION = {v1},
}

@misc{formalproof,
  author       = {Fissore, Davide},
  title        = "Elpi Formalization",
  howpublished = "\url{https://github.com/gares/elpi-formalization}",
  xmonth        = "",
  year         = "2025",
  xnote         = {{Note for the reviewer: the repository is not anonymized}},
  xannote       = ""
}
@misc{hdr,
  author       = {Tassi, Enrico},
  title        = "Elpi: rule-based extension language",
  howpublished = "\url{https://github.com/gares/HDR/blob/main/hdr.pdf}",
  xmonth        = "",
  year         = "2025",
  xnote         = {{Note for the reviewer: the repository is not anonymized}},
  xannote       = ""
}

@unpublished{fissore:hal-05026472,
  title       = {{Determinacy Checking for Elpi: an Higher-Order Logic Programming language with Cut}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-05026472},
  note        = {working paper or preprint},
  year        = {2025},
  keywords    = {Elpi ; Functionality ; Determinacy Analysis ; Higher Order ; Logic Programming ; Cut},
  pdf         = {https://inria.hal.science/hal-05026472v3/file/main.pdf},
  hal_id      = {hal-05026472},
  hal_version = {v3}
}

@inproceedings{lopez2004determinacy,
  author    = {L{\'o}pez-Garc{\'i}a, P.
               and Bueno, F.
               and Hermenegildo, M.},
  editor    = {Etalle, Sandro},
  title     = {Determinacy Analysis for Logic Programs Using Mode and Type Information},
  booktitle = {Logic Based Program Synthesis and Transformation},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {19--35},
  abstract  = {We propose an analysis for detecting procedures and goals that are deterministic (i.e. that produce at most one solution), or predicates whose clause tests are mutually exclusive (which implies that at most one of their clauses will succeed) even if they are not deterministic (because they call other predicates that can produce more than one solution). Applications of such determinacy information include detecting programming errors, performing certain high-level program transformations for improving search efficiency, optimizing low level code generation and parallel execution, and estimating tighter upper bounds on the computational costs of goals and data sizes, which can be used for program debugging, resource consumption and granularity control, etc. We have implemented the analysis and integrated it in the CiaoPP system, which also infers automatically the mode and type information that our analysis takes as input. Experiments performed on this implementation show that the analysis is fairly accurate and efficient.},
  isbn      = {978-3-540-31683-1}
}

@article{zhou2012,
  author     = {Zhou, Neng-fa},
  title      = {The language features and architecture of b-prolog},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Cambridge University Press},
  address    = {USA},
  volume     = {12},
  number     = {1–2},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068411000445},
  doi        = {10.1017/S1471068411000445},
  abstract   = {B-Prolog is a high-performance implementation of the standard Prolog language with several extensions including matching clauses, action rules for event handling, finite-domain constraint solving, arrays and hash tables, declarative loop constructs, and tabling. The B-Prolog system is based on the Tree-Oriented Abstract Machine (TOAM) architecture which differs from the Warren Abstract Machine (WAM) mainly in that (1) arguments are passed old fashionedly through the stack, (2) only one frame is used for each predicate call, and (3) instructions are provided for encoding matching trees. The most recent architecture, called TOAM Jr., departs further from the WAM in that it employs no registers for arguments or temporary variables, and provides variable-size instructions for encoding predicate calls. This paper gives an overview of the language features and a detailed description of the TOAM Jr. architecture, including architectural support for action rules and tabling.},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {189–218},
  numpages   = {30},
  keywords   = {logic programming system, Prolog}
}

@InProceedings{ciaopp,
author="Hermenegildo, Manuel V.
and Puebla, Germ{\'a}n
and Bueno, Francisco
and L{\'o}pez-Garc{\'i}a, Pedro",
editor="Cousot, Radhia",
title="Program Development Using Abstract Interpretation (And the Ciao System Preprocessor)",
booktitle="Static Analysis",
year="2003",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="127--152",
abstract="The technique of Abstract Interpretation has allowed the development of very sophisticated global program analyses which are at the same time provably correct and practical. We present in a tutorial fashion a novel program development framework which uses abstract interpretation as a fundamental tool. The framework uses modular, incremental abstract interpretation to obtain information about the program. This information is used to validate programs, to detect bugs with respect to partial specifications written using assertions (in the program itself and/or in system libraries), to generate and simplify run-time tests, and to perform high-level program transformations such as multiple abstract specialization, parallelization, and resource usage control, all in a provably correct way. In the case of validation and debugging, the assertions can refer to a variety of program points such as procedure entry, procedure exit, points within procedures, or global computations. The system can reason with much richer information than, for example, traditional types. This includes data structure shape (including pointer sharing), bounds on data structure sizes, and other operational variable instantiation properties, as well as procedure-level properties such as determinacy, termination, non-failure, and bounds on resource consumption (time or space cost). CiaoPP, the preprocessor of the Ciao multi-paradigm programming system, which implements the described functionality, will be used to illustrate the fundamental ideas.",
isbn="978-3-540-44898-3"
}
@inproceedings{10.1007/978-3-032-15981-6_5,
author = {Fissore, Davide and Tassi, Enrico},
title = {Determinacy Checking for Elpi: an Higher-Order Logic Programming Language with Cut},
year = {2026},
isbn = {978-3-032-15980-9},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-032-15981-6_5},
doi = {10.1007/978-3-032-15981-6_5},
abstract = {Elpi is a higher-order logic programming language derived from λProlog and widely used to extend the Rocq interactive theorem prover. Typical users are familiar with types and functional programming but often lack experience with backtracking.We introduce a language of signatures to declare that a predicate is operationally deterministic, meaning that calling the predicate does not leave any choice points. The signature language handles higher-order programs and dynamic programs.We present a static analyzer that verifies these signatures and report its application to the majority of public Elpi code in the Rocq ecosystem.},
booktitle = {Practical Aspects of Declarative Languages: 28th International Symposium, PADL 2026, Rennes, France, January 12–13, 2026, Proceedings},
pages = {77-95},
numpages = {19},
keywords = {Determinacy Analysis, Higher Order, Logic Programming, Cut},
location = {Rennes, France}
}@inproceedings{1990Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  xeditor    = {Rovan, Branislav},
  title     = {Retractions in comparing prolog semantics},
  booktitle = {Mathematical Foundations of Computer Science},
  year      = {1990},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {180--186},
  abstract  = {We present an operational model O and a continuation based denotational model D for a uniform variant of Prolog, including the cut operator. The two semantical definitions make use of higher order transformations $\Phi$ and $\Psi$, respectively. We prove O and D equivalent in a novel way by comparing yet another pair of higher order transformations $\Phi$ and $\Psi$, that yield $\Phi$ and $\Psi$, respectively, by application of a suitable abstraction operator.},
  isbn      = {978-3-540-47185-1}
}

@inproceedings{1989Vink,
  author    = {de Bruin, A.
               and de Vink, E. P.},
  editor    = {D{\'i}az, Josep
               and Orejas, Fernando},
  title     = {Continuation semantics for PROLOG with cut},
  booktitle = {TAPSOFT '89},
  year      = {1989},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {178--192},
  abstract  = {We present a denotational continuation semantics for PROLOG with cut. First a uniform language ℬ is studied, which captures the control flow aspects of PROLOG. The denotational semantics for ℬ is proven equivalent to a transition system based operational semantics. The congruence proof relies on the representation of the operational semantics as a chain of approximations and on a convenient induction principle. Finally, we interpret the abstract language ℬ such that we obtain equivalent denotational and operational models for PROLOG itself.},
  isbn      = {978-3-540-46116-6}
}

@phdthesis{qi2009,
  title         = {An Implementation of the Language Lambda Prolog Organized around Higher-Order Pattern Unification},
  author        = {Xiaochu Qi},
  year          = {2009},
  eprint        = {0911.5203},
  archiveprefix = {arXiv},
  booktitle = {PhD thesis},
  primaryclass  = {cs.PL},
  school = {Graduate School of the University of Minnesota},
  url           = {https://arxiv.org/abs/0911.5203}
}

@inproceedings{2003Andrews,
  author     = {Andrews, James H.},
  title      = {The witness properties and the semantics of the Prolog cut},
  year       = {2003},
  issue_date = {January 2003},
  publisher  = {Cambridge University Press},
  xaddress    = {USA},
  volume     = {3},
  number     = {1},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068402001540},
  doi        = {10.1017/S1471068402001540},
  abstract   = {The semantics of the Prolog ‘cut’ construct is explored in the context of some desirable properties of logic programming systems, referred to as the witness properties. The witness properties concern the operational consistency of responses to queries. A generalization of Prolog with negation as failure and cut is described, and shown not to have the witness properties. A restriction of the system is then described, which preserves the choice and first-solution behaviour of cut but allows the system to have the witness properties. The notion of cut in the restricted system is more restricted than the Prolog hard cut, but retains the useful first-solution behaviour of hard cut, not retained by other proposed cuts such as the ‘soft cut’. It is argued that the restricted system achieves a good compromise between the power and utility of the Prolog cut and the need for internal consistency in logic programming systems. The restricted system is given an abstract semantics, which depends on the witness properties; this semantics suggests that the restricted system has a deeper connection to logic than simply permitting some computations which are logical. Parts of this paper appeared previously in a different form in the Proceedings of the 1995 International Logic Programming Symposium (Andrews, 1995).},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {1–59},
  numpages   = {59},
  keywords   = {abstract semantics, cut, depth-first search, negation as failure, operational semantics}
}

@inproceedings{1996Somogy,
  title    = {The execution algorithm of mercury, an efficient purely declarative logic programming language},
  journal  = {The Journal of Logic Programming},
  volume   = {29},
  number   = {1},
  pages    = {17-64},
  year     = {1996},
  note     = {High-Performance Implementations of Logic Programming Systems},
  issn     = {0743-1066},
  doi      = {https://doi.org/10.1016/S0743-1066(96)00068-4},
  url      = {https://www.sciencedirect.com/science/inproceedings/pii/S0743106696000684},
  author   = {Zoltan Somogyi and Fergus Henderson and Thomas Conway},
  abstract = {We introduce Mercury, a new purely declarative logic programming language designed to provide the support that groups of application programmers need when building large programs. Mercury's strong type, mode, and determinism systems improve program reliability by catching many errors at compile time. We present a new and relatively simple execution model that takes advantage of the information these systems provide, yielding very efficient code. The Mercury compiler uses this execution model to generate portable C code. Our benchmarking shows that the code generated by our implementation is significantly faster than the code generated by mature optimizing implementations of other logic programming languages.}
}

@inproceedings{1989Warren,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jul,
  pages      = {451–481},
  numpages   = {31}
}

@inproceedings{1991Sahlin,
  author     = {Sahlin, Dan},
  title      = {Determinacy analysis for full Prolog},
  year       = {1991},
  issue_date = {Sept. 1991},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {26},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/115866.115869},
  doi        = {10.1145/115866.115869},
  journal    = {SIGPLAN Not.},
  month      = may,
  pages      = {23–30},
  numpages   = {8}
}

@inproceedings{1996mogensen,
  author    = {Mogensen, Torben \AE{}.},
  title     = {A Semantics-Based Determinacy Analysis for Prolog with Cut},
  year      = {1996},
  isbn      = {3540620648},
  publisher = {Springer-Verlag},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of the Second International Andrei Ershov Memorial Conference on Perspectives of System Informatics},
  pages     = {374–385},
  numpages  = {12}
}

@inproceedings{king2005,
  author  = {Lu, Lunjin and King, Andy},
  year    = {2005},
  month   = {04},
  pages   = {108-123},
  title   = {Determinacy Inference for Logic Programs},
  volume  = {3444},
  isbn    = {978-3-540-25435-5},
  journal = {Lecture Notes in Computer Science},
  doi     = {10.1007/978-3-540-31987-0_9}
}

@inproceedings{king2006,
  author    = {King, Andy
               and Lu, Lunjin
               and Genaim, Samir},
  editor    = {Etalle, Sandro
               and Truszczy{\'{n}}ski, Miros{\l}aw},
  title     = {Detecting Determinacy in Prolog Programs},
  booktitle = {Logic Programming},
  year      = {2006},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {132--147},
  abstract  = {In program development it is useful to know that a call to a Prolog program will not inadvertently leave a choice-point on the stack. Determinacy inference has been proposed for solving this problem yet the analysis was found to be wanting in that it could not infer determinacy conditions for programs that contained cuts or applied certain tests to select a clause. This paper shows how to remedy these serious deficiencies. It also addresses the problem of identifying those predicates which can be rewritten in a more deterministic fashion. To this end, a radically new form of determinacy inference is introduced, which is founded on ideas in ccp, that is capable of reasoning about the way bindings imposed by a rightmost goal can make a leftmost goal deterministic.},
  isbn      = {978-3-540-36636-2}
}


@inproceedings{2011king,
  title     = {RedAlert: Determinacy inference for Prolog},
  author    = {Kriener, Jael and King, Andy},
  journal   = {Theory and Practice of Logic Programming},
  volume    = {11},
  number    = {4-5},
  pages     = {537--553},
  year      = {2011},
  publisher = {Cambridge University Press}
}

@inproceedings{1996henderson,
  author = {Henderson, Fergus and Somogyi, Zoltan and Conway, Thomas},
  year   = {1996},
  month  = {08},
  booktitle = {Proceedings of Australian Computer Science Conference},
  pages  = {337-346},
  title  = {Determinism analysis in the Mercury compiler}
}

@inproceedings{1987vanroy,
  title        = {Improving the execution speed of compiled Prolog with modes, clause selection, and determinism},
  author       = {Van Roy, Peter and Demoen, Bart and Willems, Yves D},
  booktitle    = {TAPSOFT'87: Proceedings of the International Joint Conference on Theory and Practice of Software Development Pisa, Italy, March 23--27, 1987 2},
  pages        = {111--125},
  year         = {1987},
  organization = {Springer}
}

@inproceedings{2002overton,
  author    = {Overton, David and Somogyi, Zoltan and Stuckey, Peter J.},
  title     = {Constraint-based mode analysis of mercury},
  year      = {2002},
  isbn      = {1581135289},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/571157.571169},
  doi       = {10.1145/571157.571169},
  abstract  = {Recent logic programming languages, such as Mercury and HAL, require type, mode and determinism declarations for predicates. This information allows the generation of efficient target code and the detection of many errors at compile-time. Unfortunately, mode checking in such languages is difficult. One of the main reasons is that, for each predicate mode declaration, the compiler is required to decide which parts of the procedure bind which variables, and how conjuncts in the predicate definition should be re-ordered to enforce this behaviour. Current mode checking systems limit the possible modes that may be used because they do not keep track of aliasing information, and have only a limited ability to infer modes, since inference does not perform reordering. In this paper we develop a mode inference system for Mercury based on mapping each predicate to a system of Boolean constraints that describe where its variables can be produced. This allows us handle programs that are not supported by the existing system.},
  booktitle = {Proceedings of the 4th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  pages     = {109–120},
  numpages  = {12},
  keywords  = {Boolean constraints, mode analysis, modes},
  location  = {Pittsburgh, PA, USA},
  series    = {PPDP '02}
}

@inproceedings{1994apt-oc,
  author     = {Apt, Krzysztof R. and Pellegrini, Alessandro},
  title      = {On the occur-check-free PROLOG programs},
  year       = {1994},
  issue_date = {May 1994},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {16},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/177492.177673},
  doi        = {10.1145/177492.177673},
  abstract   = {In most PROLOG implementations, for efficiency occur-check is omitted from the unification algorithm. This paper provides natural syntactic conditions that allow the occur-check to be safely omitted. The established results apply to most well-known PROLOG programs, including those that use difference lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs, we show their usefulness for proving absence of floundering. Finally, we propose a program transformation that transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = may,
  pages      = {687–726},
  numpages   = {40},
  keywords   = {PROLOG programs, moded programs, occur-check problem, unification algorithm}
}

@inproceedings{1996pfenning,
  author    = {Rohwedder, Ekkehard
               and Pfenning, Frank},
  editor    = {Nielson, Hanne Riis},
  title     = {Mode and termination checking for higher-order logic programs},
  booktitle = {Programming Languages and Systems --- ESOP '96},
  year      = {1996},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  pages     = {296--310},
  abstract  = {We consider how mode (such as input and output) and termination properties of typed higher-order constraint logic programming languages may be declared and checked effectively. The systems that we present have been validated through an implementation and numerous case studies.},
  isbn      = {978-3-540-49942-8}
}



@book{1991ait-wam,
  author    = {Aït-Kaci, Hassan},
  title     = {Warren's Abstract Machine: A Tutorial Reconstruction},
  publisher = {The MIT Press},
  year      = {1991},
  month     = {08},
  abstract  = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.Contents Introduction • Unification—Pure and Simple • Flat Resolution • Prolog • Optimizing the Design • Conclusion • Appendixes},
  isbn      = {9780262255585},
  doi       = {10.7551/mitpress/7160.001.0001},
  url       = {https://doi.org/10.7551/mitpress/7160.001.0001}
}


@techreport{1992nadathur,
author = {Nadathur, Gopalan and Pfenning, Frank},
title = {The Type System of a Higher-Order Logic Programming Language},
year = {1992},
note = {Duke University},
xaddress = {USA},
abstract = {The type system of the logic programming language $lambda$Prolog is discussed. The incorporation of higher-order notions within this language requires the use of a typing scheme to distinguish between expressions of different function types. Thus $lambda$Prolog is a (strongly) typed language, in contrast to the typeless language that underlies the idea of descriptive types in logic programming. The typing discipline that is employed in the language is based on the notion of simple types in the $lambda$-calculus. This form of typing enforces arity restrictions on functions and predicates and provides a builtin functional hierarchy over terms. The language contains a facility for defining new primitive types and thus permits finer grained distinctions to be introduced by the user. Further, the use of type variables and type constructors provides a form of polymorphism that is similar in certain respects to that present in the language ML. The notion of type checking in $lambda$Prolog is discussed and shown to be an operation that can be performed at the time of compilation. The value of typing distinctions in determining the clarity of programs and their usefulness in conjunction with type checking in preventing run-time errors due to type violations is also discussed. In addition to their function in type checking, types also have a major role in determining computations in the logic programming context. We discuss this aspect of types that is in contrast to their behavior in other programming paradigms and we show how this leads to a presence of types in the runtime environment. While typing has several advantages, it is sometimes to the programmer''s advantage to be able to omit their mention. Type reconstruction provides a means for filling missing type information in and we discuss issues pertinent to this process in the context of $lambda$Prolog.}
}

@inproceedings{1988pfenning,
  author    = {Pfenning, F. and Elliott, C.},
  title     = {Higher-order abstract syntax},
  year      = {1988},
  isbn      = {0897912691},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/53990.54010},
  doi       = {10.1145/53990.54010},
  abstract  = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
  booktitle = {Proceedings of PLDI},
  pages     = {199–208},
  numpages  = {10},
  location  = {Atlanta, Georgia, USA},
  xseries    = {PLDI '88}
}

@inproceedings{Miller2018MechanizedMR,
  title={Mechanized Metatheory Revisited},
  author={Dale A. Miller},
  journal={Journal of Automated Reasoning},
  booktitle={Journal of Automated Reasoning},
  year={2018},
  volume={63},
  pages={625-665},
  publisher="Springer",
}

@inproceedings{wadler1996-hs,
  author     = {Hall, Cordelia V. and Hammond, Kevin and Peyton Jones, Simon L. and Wadler, Philip L.},
  title      = {Type classes in Haskell},
  year       = {1996},
  issue_date = {March 1996},
  publisher  = {Association for Computing Machinery},
  xaddress    = {New York, NY, USA},
  volume     = {18},
  number     = {2},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/227699.227700},
  doi        = {10.1145/227699.227700},
  abstract   = {This article defines a set of type inference rules for resolving overloading introduced by type classes, as used in the functional programming language Haskell. Programs including type classes are transformed into ones which may be typed by standard Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to Haskell programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the transformed program.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = mar,
  pages      = {109–138},
  numpages   = {30},
  keywords   = {Haskell, functional programming, type classes, types}
}


@InProceedings{sozeau2008-tc,
author="Sozeau, Matthieu and Oury, Nicolas",
title="First-Class Type Classes",
booktitle="Proceedings of TPHOLs",
year="2008",
publisher="Springer",
  series =       "LNCS",
  volume = {5170},
xaddress="Berlin, Heidelberg",
pages="278--293",
abstract="Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.",
isbn="978-3-540-71067-7"
}


@inproceedings{nakamura1986,
  author    = {Nakamura, Katsuhiko},
  title     = {Control of Logic Program Execution Based on the Functional Relations},
  year      = {1986},
  isbn      = {3540164928},
  publisher = {Springer},
  xaddress   = {Berlin, Heidelberg},
  booktitle = {Proceedings of ICLP},
  pages     = {505–512},
  numpages  = {8}
}

@inproceedings{wadler1989,
  author    = {Wadler, Philip},
  title     = {Theorems for free!},
  year      = {1989},
  isbn      = {0897913280},
  publisher = {Association for Computing Machinery},
  xaddress   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/99370.99404},
  doi       = {10.1145/99370.99404},
  booktitle = {Proceedings of FPCA},
  pages     = {347–359},
  numpages  = {13},
  xlocation  = {Imperial College, London, United Kingdom},
  series    = {FPCA '89}
}

@phdthesis{enzo,
  title        = {Meta-Programming for Proof Transfer in Dependent Type Theory},
  author       = {Enzo Crance},
  year         = 2023,
  month        = {December},
  address      = {Nantes},
  note         = {Available at \url{https://ecrance.net/files/thesis-Enzo-Crance-en-light.pdf}},
  school       = {University of Nantes},
  type         = {PhD thesis}
}

@mastersthesis{Maas2024,
  author      = {Luko van der Maas},
  title       = {Extending the {I}ris {P}roof {M}ode with Inductive Predicates using {E}lpi},
  school      = {Radboud University Nijmegen},
  doi         = {10.5281/zenodo.12568604},
  year        = {2024}
}
@book{mcb,
  author       = {Assia Mahboubi and
                  Enrico Tassi},
  title        = {Mathematical Components},
  publisher    = {Zenodo},
  year         = 2022,
  month        = sep,
  doi          = {10.5281/zenodo.7118596},
  url          = {https://doi.org/10.5281/zenodo.7118596},
  keywords = "inria:book",
}

@inproceedings{hanus2025,
  author    = {Hanus, Michael and Prott, Kai-Oliver},
  title     = {{Determinism Types for Functional Logic Programming}},
  booktitle = {Proceedings of PPDP},
  pages     = {47--59},
  xseries = {PPDP '25},
  year = {2025}
}

@inproceedings{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13,
  author       = {Georges Gonthier and
                  Andrea Asperti and
                  Jeremy Avigad and
                  Yves Bertot and
                  Cyril Cohen and
                  Fran{\c{c}}ois Garillot and
                  St{\'{e}}phane Le Roux and
                  Assia Mahboubi and
                  Russell O'Connor and
                  Sidi Ould Biha and
                  Ioana Pasca and
                  Laurence Rideau and
                  Alexey Solovyev and
                  Enrico Tassi and
                  Laurent Th{\'{e}}ry},
  editor       = {Sandrine Blazy and
                  Christine Paulin{-}Mohring and
                  David Pichardie},
  title        = {A Machine-Checked Proof of the Odd Order Theorem},
  booktitle    = {Interactive Theorem Proving - 4th International Conference, {ITP}
                  2013, Rennes, France, July 22-26, 2013. Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {7998},
  pages        = {163--179},
  publisher    = {Springer},
  year         = {2013},
  url          = {https://inria.hal.science/hal-00816699v1},
  doi          = {10.1007/978-3-642-39634-2_14},
  timestamp    = {Sat, 30 Sep 2023 01:00:00 +0200},
  biburl       = {https://dblp.org/rec/conf/itp/GonthierAABCGRMOBPRSTT13.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org},
    keywords = "inria:paper, inria:proud",

}

@techreport{gonthier:hal-04034866,
  TITLE = {{A computer-checked proof of the Four Color Theorem}},
  AUTHOR = {Gonthier, Georges},
  URL = {https://inria.hal.science/hal-04034866},
  INSTITUTION = {{Inria}},
  YEAR = {2023},
  MONTH = Mar,
  PDF = {https://inria.hal.science/hal-04034866v1/file/FINALA%20computer-checked%20proof%20of%20the%20four%20color%20theorem%20-%20HAL.pdf},
  HAL_ID = {hal-04034866},
  HAL_VERSION = {v1},
}

@misc{formalproof,
  author       = {Fissore, Davide},
  title        = "Elpi Formalization",
  howpublished = "\url{https://github.com/gares/elpi-formalization}",
  xmonth        = "",
  year         = "2025",
  xnote         = {{Note for the reviewer: the repository is not anonymized}},
  xannote       = ""
}
@misc{hdr,
  author       = {Tassi, Enrico},
  title        = "Elpi: rule-based extension language",
  howpublished = "\url{https://github.com/gares/HDR/blob/main/hdr.pdf}",
  xmonth        = "",
  year         = "2025",
  xnote         = {{Note for the reviewer: the repository is not anonymized}},
  xannote       = ""
}

@unpublished{fissore:hal-05026472,
  title       = {{Determinacy Checking for Elpi: an Higher-Order Logic Programming language with Cut}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-05026472},
  note        = {working paper or preprint},
  year        = {2025},
  keywords    = {Elpi ; Functionality ; Determinacy Analysis ; Higher Order ; Logic Programming ; Cut},
  pdf         = {https://inria.hal.science/hal-05026472v3/file/main.pdf},
  hal_id      = {hal-05026472},
  hal_version = {v3}
}

@inproceedings{lopez2004determinacy,
  author    = {L{\'o}pez-Garc{\'i}a, P.
               and Bueno, F.
               and Hermenegildo, M.},
  editor    = {Etalle, Sandro},
  title     = {Determinacy Analysis for Logic Programs Using Mode and Type Information},
  booktitle = {Logic Based Program Synthesis and Transformation},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {19--35},
  abstract  = {We propose an analysis for detecting procedures and goals that are deterministic (i.e. that produce at most one solution), or predicates whose clause tests are mutually exclusive (which implies that at most one of their clauses will succeed) even if they are not deterministic (because they call other predicates that can produce more than one solution). Applications of such determinacy information include detecting programming errors, performing certain high-level program transformations for improving search efficiency, optimizing low level code generation and parallel execution, and estimating tighter upper bounds on the computational costs of goals and data sizes, which can be used for program debugging, resource consumption and granularity control, etc. We have implemented the analysis and integrated it in the CiaoPP system, which also infers automatically the mode and type information that our analysis takes as input. Experiments performed on this implementation show that the analysis is fairly accurate and efficient.},
  isbn      = {978-3-540-31683-1}
}

@article{zhou2012,
  author     = {Zhou, Neng-fa},
  title      = {The language features and architecture of b-prolog},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Cambridge University Press},
  address    = {USA},
  volume     = {12},
  number     = {1–2},
  issn       = {1471-0684},
  url        = {https://doi.org/10.1017/S1471068411000445},
  doi        = {10.1017/S1471068411000445},
  abstract   = {B-Prolog is a high-performance implementation of the standard Prolog language with several extensions including matching clauses, action rules for event handling, finite-domain constraint solving, arrays and hash tables, declarative loop constructs, and tabling. The B-Prolog system is based on the Tree-Oriented Abstract Machine (TOAM) architecture which differs from the Warren Abstract Machine (WAM) mainly in that (1) arguments are passed old fashionedly through the stack, (2) only one frame is used for each predicate call, and (3) instructions are provided for encoding matching trees. The most recent architecture, called TOAM Jr., departs further from the WAM in that it employs no registers for arguments or temporary variables, and provides variable-size instructions for encoding predicate calls. This paper gives an overview of the language features and a detailed description of the TOAM Jr. architecture, including architectural support for action rules and tabling.},
  journal    = {Theory Pract. Log. Program.},
  month      = jan,
  pages      = {189–218},
  numpages   = {30},
  keywords   = {logic programming system, Prolog}
}

@InProceedings{ciaopp,
author="Hermenegildo, Manuel V.
and Puebla, Germ{\'a}n
and Bueno, Francisco
and L{\'o}pez-Garc{\'i}a, Pedro",
editor="Cousot, Radhia",
title="Program Development Using Abstract Interpretation (And the Ciao System Preprocessor)",
booktitle="Static Analysis",
year="2003",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="127--152",
abstract="The technique of Abstract Interpretation has allowed the development of very sophisticated global program analyses which are at the same time provably correct and practical. We present in a tutorial fashion a novel program development framework which uses abstract interpretation as a fundamental tool. The framework uses modular, incremental abstract interpretation to obtain information about the program. This information is used to validate programs, to detect bugs with respect to partial specifications written using assertions (in the program itself and/or in system libraries), to generate and simplify run-time tests, and to perform high-level program transformations such as multiple abstract specialization, parallelization, and resource usage control, all in a provably correct way. In the case of validation and debugging, the assertions can refer to a variety of program points such as procedure entry, procedure exit, points within procedures, or global computations. The system can reason with much richer information than, for example, traditional types. This includes data structure shape (including pointer sharing), bounds on data structure sizes, and other operational variable instantiation properties, as well as procedure-level properties such as determinacy, termination, non-failure, and bounds on resource consumption (time or space cost). CiaoPP, the preprocessor of the Ciao multi-paradigm programming system, which implements the described functionality, will be used to illustrate the fundamental ideas.",
isbn="978-3-540-44898-3"
}
